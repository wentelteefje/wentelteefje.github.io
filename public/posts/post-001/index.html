<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Smart Contracts of the Ethereum Name Service | a5xz2</title>
<meta name=keywords content="solidity,ethereum"><meta name=description content="This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/post-001/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e8e1ca2b036c6bcbd582af4b216275873849c35585cc3b2d6e825eca803671c6.css integrity="sha256-6OHKKwNsa8vVgq9LIWJ1hzhJw1WFzDstboJeyoA2ccY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/post-001/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="The Smart Contracts of the Ethereum Name Service"><meta property="og:description" content="This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/post-001/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-16T00:33:46+02:00"><meta property="article:modified_time" content="2022-08-16T00:33:46+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Smart Contracts of the Ethereum Name Service"><meta name=twitter:description content="This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"The Smart Contracts of the Ethereum Name Service","item":"http://localhost:1313/posts/post-001/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Smart Contracts of the Ethereum Name Service","name":"The Smart Contracts of the Ethereum Name Service","description":"This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS.","keywords":["solidity","ethereum"],"articleBody":"1. Introduction 1.1 What is the Ethereum Name Service (ENS)? Most people probably first learn about the ENS from seeing people having .eth names as their twitter account name, for example vitalik.eth. The smart contracts of the ENS make it possible to resolve such a name as vitalik.eth to some registered Ethereum address (currently it resolves to: 0xd8da6bf26964af9d7eed9e03e53415d37aa96045). This is a very useful feature for all users of Ethereum and most common web3 applications, such as MetaMask or DeBank already have it integrated. However, while the resolution of names to Ethereum addresses certainly is currently the biggest application of the ENS it’s by far not the only use case. Among other things the ENS also allows your name to resolve to\ncrypto address of other blockchains, content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses), contract interfaces (ABIs), or any text-based metadata. This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS. First, we are going to explore the basic building blocks of the system. Afterwards, we dig deeper into the workings of the so-called permanent registrar, which is responsible for handing out .eth names to Ethereum users.\n1.2 The Big Picture Before we dive deeper let’s take a bird’s eye view on the ENS. The most fundamental component is the ENS registry, which stores data about names and in particular can determine the responsible resolver for each name. The registry is a single smart contract, but in principle there can be many active resolvers in the system. A resolver fulfills a very similar task as a DNS resolver: When it receives a name, it responds by returning the associated resource, which, in the simplest case would be an Ethereum address. Lastly, there are registrars, which are smart contracts responsible for allocating subdomains. Similar to resolvers, there can be many registrars and they can exist at any level of the hierarchy. For example, if you own the name “alice.eth” it means you can deploy your very own registrar contract and transfer to it the ownership of your domain. This contract can then be used to issue subdomains of the type x.alice.eth to users and you can freely make up the rules for who gets a subdomain. But since we are getting ahead of ourselves, we will come back to this topic later.\n2. The Core Contracts of the ENS 2.1 Names and Nodes The smart contracts of the ENS revolve around the concept of a node, which in this context is defined as a hash uniquely identifying a name. A name in turn is an ENS identifier, such as “alice.eth”, which can be comprised of multiple labels each separated by a dot. That is “worm” or “wen.wide.vitalik.eth” are both valid names. Note, that the rightmost label is the equivalent to TLDs in DNS. Currently, “worm” doesn’t exist as a domain name on Ethereum mainnet, but there’s nothing in the code to prevent it from existing.\nNow, there are a few caveats to human-readable names when it comes to using them on-chain. In particular, working with strings in Solidity can get messy quite fast and is also not very efficient. Using a hash function to obtain a fixed-length representation of names is therefore the obvious solution. This fixed-length representation of a names is going to be what we called a node above. Since nodes provide the internal representation of names in the ENS we capture their formal definition here.\nDefinition: A node is a bytes32 identifier, which is obtained from an ENS name by first normalising it according to UTS-46 and then applying the Namehash algorithm to it.\nAt this point, it’s not really necessary to know anything about Unicode UTS-46, but you should be aware that it exists. Among other things, the normalisation according to UTS-46 checks the names for validity (for example underscores are prohibited) and converts all names to lowercase.\nHowever, the Namehash algorithm is the heart of the ENS and therefore we have to take a close look at it first. Fortunately for us, its definition is very compact and easy to understand by means of an example. The full scope of its definition is a bit more difficult to understand, but we will come back to it at the appropriate place and by the end of the article you should have become aware of its prominent position in the ENS.\nnamehash([]) = 0x0 namehash([label, …]) = keccak256(namehash(…), keccak256(label)) This pseudo-code implementation of Namehash expects a name in list form, i.e. the name is split into its labels using the dot as a separator. An example: ‘vitalik.eth’ becomes [‘vitalik’, ’eth’], ‘vitalik.wallet.eth’ becomes [‘vitalik’, ‘wallet’, ’eth’] etc. The base case for the recursion is the empty list [] for which the algorithm returns 0x0 (note: 0x0 is short for a 32 byte zero). Through recursion implemented in the second line, each label is hashed first and then, starting with the rightmost list entry, the previous calculation is concatenated with the label hash and hashed again. The most basic non-trivial example we can give is the calculation of ’eth’:\n1. namehash(['eth']) = keccak256(namehash([]), keccak256('eth')) 2. namehash(['eth']) = keccak256(0x0, keccak256('eth')) 3. namehash(['eth']) = keccak256(0x0, 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0) 4. namehash(['eth']) = keccak256(0x00000000000000000000000000000000000000000000000000000000000000004f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0) 5. namehash(['eth']) = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae It’s worth highlighting that both normalisation and hashing are processes which are executed off-chain (if possible). Let’s finally move on to the actual contracts.\n2.2 The ENS Registry The core on-chain component of the ENS is the registry. This smart contract is essentially a record-keeping device. Every name at every level gets an entry here.\nThis entry contains the owner of the name, the associated resolver, as well as a caching time-to-live (TTL). In the actual smart contract this data is stored by mapping nodes to a struct:\nstruct Record { address owner; address resolver; uint64 ttl; } mapping (bytes32 =\u003e Record) records; Let’s look at the contract deployment and the first steps after that. The constructor is actually just one line, which saves the contract deployer as the owner of the node 0x0 in the records mapping:\nconstructor() public { records[0x0].owner = msg.sender; } Therefore, a new ENS registry starts out with only one record attached to the node 0x0. The name “node” is no coincidence: the ENS name space follows a tree structure and 0x0 is the root node. Of course, it is not a binary tree, but each “TLD name” is a child node of 0x0. Now, let’s see how to register our first name! From the point of view of the root node every new node is a subnode, so we need to inspect the following method.\nfunction setSubnodeOwner(bytes32 node, bytes32 label, address owner) public authorised(node) returns(bytes32) { bytes32 subnode = keccak256(abi.encodePacked(node, label)); _setOwner(subnode, owner); emit NewOwner(node, label, owner); return subnode; } First, this function can only be called by the owner of node (guaranteed by the authorised modifier). This is a crucial point of the implementation. Before continuing let’s take a look at that modifier:\nmodifier authorised(bytes32 node) { address owner = records[node].owner; require(owner == msg.sender || operators[owner][msg.sender]); _; } We can safely ignore the operators mapping for now, as it’s only used to allow another account to manage one’s node. The main takeaway is that in the default state of the contract this modifier is only passed, when the msg.sender address is registered in the owner field of node. We’ll get to the implications of this shortly.\nLet’s continue with setSubnodeOwner. Alongside the parent node we also need to pass the keccak256 hash of the label, as well as the address of the intended owner of the new subnode. Note, that the first line is nothing more as calculating the Namehash of the new subnode. Since node is already namehashed we can calculate it easily in one step. This is followed up by an internal call to _setOwner which registers the new subnode for it’s owner:\nfunction _setOwner(bytes32 node, address owner) internal virtual { records[node].owner = owner; } As you can see, the tree structure is not explicitly captured in the records mapping. The tree hierarchy is only guaranteed by the way Namehash works and that is perfectly sufficient. This is a really elegant and resource-aware solution which serves as a good example of how blockchain development differs from traditional software development.\nIn fact, the tree structure encoded in the naming is primarily a hierarchy of access rights. Recall, that the “authorised” modifier acts at the level of a node and not at the level of the label in question. This means that the owner of a node can use setSubnodeOwner to override any of its subnodes, even if they are not registered as the owner of those subnodes in the registry. Therefore, the owner of 0x0 has full control over all nodes.\nNow, since we started from a freshly deployed ENS the only node we can pass to setSubnodeOwner is the root node 0x0. If we wanted to establish the eth subdomain we first would have to calculate its keccak256 hash,keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0, and pass that as label. Technically, we would have to normalize the label first according to UTS-46, but the string “eth” is already normalized. In a real application, however, this would be a necessary first step. The owner field is necessary for handing over control over a subnode to an address that is not the ENS registry deployer address.\nThat’s all we need to know about the registry for now. You can find the whole source code here.\n2.3 Resolvers In order for a node to be used within ENS, a resolver must be assigned to it. This can only be done by the current owner of the node. To do this, the owner must call the setResolver method of the ENS registry and pass the node as well as the address of the new resolver.\nfunction setResolver(bytes32 node, address resolver) public virtual override authorised(node) { emit NewResolver(node, resolver); records[node].resolver = resolver; } The basic requirement for a resolver contract is that it is ERC-165 compliant, i.e. it implements a supportsInterface method as specified in EIP-165. The idea is that a name in ENS can potentially be resolved to many different things (as described in the introduction) and not every resolver needs to implement every possible use case. The first example of a resolver we can give is therefore the empty resolver:\ncontract EmptyResolver { function supportsInterface(bytes4 interfaceID) public pure returns (bool) { return interfaceID == 0x01ffc9a7; } } Okay, that’s maybe not very useful. A more instructive, but still quite simple example is an address resolver. In this scenario, owners of a node can link their node to an Ethereum address. Note that this info is stored in a node =\u003e address mapping on the level of the resolver and not in the ENS registry.\ncontract SimpleAddrResolver { ENS ens; mapping (bytes32 =\u003e address) addresses; modifier authorised(bytes32 node) { require(isAuthorised(node)); _; } constructor(ENS _ens) { ens = _ens; } function supportsInterface(bytes4 interfaceID) public pure returns (bool) { return interfaceID == 0x01ffc9a7 || interfaceID == 0x3b3b57de; } function isAuthorised(bytes32 node) internal view returns(bool) { address owner = ens.owner(node); return owner == msg.sender; } function addr(bytes32 node) public view returns (address) { return addresses[node]; } function setAddr(bytes32 node, address addr) external authorised(node) { addresses[node] = addr; } } However, with every request to change the mapping of a node to an address (setAddr), the ENS registry is queried for the owner of the respective node. So at this point the registry is incorporated into the process by the address resolver.\nNow we are ready to understand how name to address resolution works in the ENS. The following image from the ENS docs shows the name resolution procedure for “foo.eth”. First by calling resolver we inquire the ENS registry about the responsible resolver for “foo.eth”. Afterwards, we ask the received resolver for the Ethereum address for “foo.eth” by calling addr.\nA small side note: It is important to start with the name resolution at the level of the registry, because only the registry knows which resolver is currently responsible for the respective name. Even if you think you already know the correct resolver address, it may have been changed over time or it may even have been part of a phishing attack.\nThere are many different kinds of implementations for resolvers, which vary depending on the use case. A common extension of the address resolver mentioned above is to allow support for storing addresses of other block chains. This way, several crypto addresses can be stored for one name at the same time. This is implemented by extending the address mapping to two variables: Given values for node and coinType it yields a bytes-type object:\nmapping(bytes32 =\u003e mapping(uint256 =\u003e bytes)) addresses; The desired coinType follows SLIP-0044 and must be specified for the name resolution. Therefore, the getter and setter methods now take the form:\nfunction addr(bytes32 node, uint256 coinType) public view returns (bytes memory) { return addresses[node][coinType]; } function setAddr(bytes32 node, uint256 coinType, bytes memory a) public authorised(node) { addresses[node][coinType] = a; } The EIP165 interface ID for this multicoin addr function is 0xf1cb7e06.\nThis concludes our introduction to resolver contracts. For further reading, the chapter on the PublicResolver from the official ENS documentation is recommended as a starting point.\n2.4 Registrars We have so far covered the two main components of the Ethereum Name Service. In the section on the registry, we saw that each node owner can in principle create as many subnodes as they wish. In practice, however, the creation of subnodes is typically managed by a smart contract, which can freely specify the conditions for acquiring a subdomain. In particular, this is the case for Top-Level Domains like “.eth”. These smart contracts are called registrars. By design, each person who owns a domain (on any level) can manage the subdomains themselves, i.e. they can also deploy and use a registrar contract for administration as they wish.\nLet’s look at an example. This registrar implementation allows anyone to call register, to obtain a subnode of some fixed parent node. After a period of 4 weeks the subnode will be available for registration again.\ncontract TestRegistrar { uint constant registrationPeriod = 4 weeks; ENS ens; bytes32 public parentNode; mapping (bytes32 =\u003e uint) public expiryTimes; constructor(ENS _ens, bytes32 _node) public { ens = _ens; parentNode = _node; } function register(bytes32 label, address owner) public { require(expiryTimes[label] \u003c block.timestamp); expiryTimes[label] = block.timestamp + registrationPeriod; ens.setSubnodeOwner(parentNode, label, owner); } } As you can see in the last line of the register function, after checking availability the contract just calls setSubnodeOwner at the ENS registry on behalf of the user. For this to work the TestRegistrar contract must hold ownership of parentNode, i.e. the registrar’s address must have been stored in the ENS registry for parentNode.\nOne especially useful application of registrars is reverse resolution, that is the process of mapping an Ethereum address to an ENS name. On mainnet the ReverseRegistrar implements reverse lookup as an opt-in process. It controls the addr.reverse domain and allows any user to call its setName function in order to have their Ethereum address linked with their domain.\nfunction setName(string memory name) public returns (bytes32) { bytes32 node = claimWithResolver(address(this), address(defaultResolver)); defaultResolver.setName(node, name); return node; } We will not go into all the implementation details here, but describe the process briefly instead. The first line of setName accomplishes two things. First, the calling account is given ownership over the associated reverse ENS record. A reverse ENS record is simply a conventional ENS record which is used for the purpose of reverse resolution. In other words, a caller with the account 0x314159265dd8dbb310642f98f50c066173c1259b afterwards owns the subdomain 0x314159265dd8dbb310642f98f50c066173c1259b.addr.reverse. Next, a special type of resolver, called a reverse resolver is set as the resolver in the reverse record. Finally, in the second line, the user’s provided name is supplied to the setName function of this reverse resolver (called defaultResolver above). The following contract is a simplified version of a reverse resolver.\ncontract ReverseResolver { ENS ens; mapping(bytes32=\u003estring) public name; constructor(ENS _ens) public { ens = _ens; } modifier owner_only(bytes32 node) { require(msg.sender == ens.owner(node)); _; } function setName(bytes32 node, string calldata _name) public owner_only(node) { name[node] = _name; } function name(bytes32 node) public view returns (string memory) { return names[node]; } } In summary, reverse resolution works exactly like normal resolution, except that an Ethereum address is used as a label for the subdomain.\nAs you can see registrars offer many possibilities to use your ENS domain in creative ways. They complement the functionality of registry and resolvers and are the final part of our presentation of the ENS core contracts.\n3. The Permanent Registrar Whew! Congratulations if you have made it this far - you are already familiar with all the basic components of the Ethereum Name Service. In this final section, we’ll have a look at some cool aspects of the .eth Permanent Registrar. This is the smart contract that manages the allocation of .eth domains on the Ethereum mainnet.\n3.1 .eth Domains are ERC-721 Tokens Certainly one of the coolest features of the Permanent Registrar is that it’s fully ERC-721 compliant, i.e. “.eth” domains are tradable as NFTs. According to EIP-721 the identifier of an NFT, its tokenId, must be a uint256. In the implementation of the Permanent Registrar it was decided to use the uint256 representation of the label hashes for the tokenId. Therefore, the contract uses uint256 instead of bytes32 for labels and then casts back to bytes32 when interacting with the registry. In the code snippet below you can see part of the process of registering a domain with the registrar.\nfunction _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) { require(available(id)); require(now + duration + GRACE_PERIOD \u003e now + GRACE_PERIOD); // Prevent future overflow expiries[id] = now + duration; if(_exists(id)) { // Name was previously owned, and expired _burn(id); } _mint(owner, id); if(updateRegistry) { ens.setSubnodeOwner(baseNode, bytes32(id), owner); } emit NameRegistered(id, owner, now + duration); return now + duration; } You can also see how the mint and burn processes of the ERC-721 token are handled during (re-)registration. Maybe you also noticed the two modifiers, live and onlyController. The live modifier checks whether the current Permanent Registrar contract is still in use, while the onlyController modifier restricts access for the _register function to registered controllers. Instead of users registering or renewing a domain directly with the Permanent Registrar, this is done via separate Controller smart contracts. The controller contract registers the domain on behalf of the buyer with the Permanent Registrar and afterwards transfers full ownership to them.\n3.2 Reclaiming Ownership of a Name However, not all user requests are handled by the controller. If you somehow lose ownership over your domain’s registration at the ENS registry, but are still in possession of your ERC-721 token you can reclaim ownership of your registry records by calling the reclaim function of the Permanent Registrar.\n/** * @dev Reclaim ownership of a name in ENS, if you own it in the registrar. */ function reclaim(uint256 id, address owner) external live { require(_isApprovedOrOwner(msg.sender, id)); ens.setSubnodeOwner(baseNode, bytes32(id), owner); } As a fully ERC-721 compliant contract the registrar also needs to store all data relevant to the NFT. The reclaim function uses _isApprovedOrOwner to check eligibility. When the check is passed a single call to setSubnodeOwner sets the record straight. The following is an excerpt of OpenZeppelin’s ERC-721 implementation as inherited by the Permanent Registrar:\n// Mapping from token ID to owner address mapping(uint256 =\u003e address) private _owners; // Mapping from token ID to approved address mapping(uint256 =\u003e address) private _tokenApprovals; // Mapping from owner to operator approvals mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals; // Returns whether `spender` is allowed to manage `tokenId`. function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) { address owner = ERC721.ownerOf(tokenId); return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender); } 4. A Small Exercise This concludes our little excursion into the smart contracts of the ENS. I would like to dismiss you with a little voluntary exercise: While domains like “alice.eth” are ERC-721 tokens, this does not apply to their subdomains.\nWhy is this the case? Think about how you can still convert your subdomains into NFTs. (Hint: Registrar.) You can find a solution here in the ENS documentation.\n*All images are from the official ENS documentation, where you can also find more detailed information on most topics. Thanks for reading and if you found an error or have further questions please feel free to contact me. *\n","wordCount":"3434","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-08-16T00:33:46+02:00","dateModified":"2022-08-16T00:33:46+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/post-001/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">The Smart Contracts of the Ethereum Name Service</h1><div class=post-meta><span title='2022-08-16 00:33:46 +0200 CEST'>August 16, 2022</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/post-001.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-what-is-the-ethereum-name-service-ens>1.1 What is the Ethereum Name Service (ENS)?</a></li><li><a href=#12-the-big-picture>1.2 The Big Picture</a></li></ul><ul><li><a href=#21-names-and-nodes>2.1 Names and Nodes</a></li><li><a href=#22-the-ens-registry>2.2 The ENS Registry</a></li><li><a href=#23-resolvers>2.3 Resolvers</a></li><li><a href=#24-registrars>2.4 Registrars</a></li></ul><ul><li><a href=#31-eth-domains-are-erc-721-tokens>3.1 .eth Domains are ERC-721 Tokens</a></li><li><a href=#32-reclaiming-ownership-of-a-name>3.2 Reclaiming Ownership of a Name</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h1><h2 id=11-what-is-the-ethereum-name-service-ens>1.1 What is the Ethereum Name Service (ENS)?<a hidden class=anchor aria-hidden=true href=#11-what-is-the-ethereum-name-service-ens>#</a></h2><p>Most people probably first learn about the ENS from seeing people having <code>.eth</code> names as their twitter account name, for example <code>vitalik.eth</code>. The smart contracts of the ENS make it possible to resolve such a name as <code>vitalik.eth</code> to some registered Ethereum address (currently it resolves to: <code>0xd8da6bf26964af9d7eed9e03e53415d37aa96045</code>). This is a very useful feature for all users of Ethereum and most common web3 applications, such as MetaMask or DeBank already have it integrated. However, while the resolution of names to Ethereum addresses certainly is currently the biggest application of the ENS it&rsquo;s by far not the only use case. Among other things the ENS also allows your name to resolve to</p><ul><li>crypto address of other blockchains,</li><li>content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses),</li><li>contract interfaces (ABIs),</li><li>or any text-based metadata.</li></ul><p>This article aims to give an introduction to the ENS for blockchain developers by going through the smart contracts lying at the core of ENS. First, we are going to explore the basic building blocks of the system. Afterwards, we dig deeper into the workings of the so-called permanent registrar, which is responsible for handing out <code>.eth</code> names to Ethereum users.</p><h2 id=12-the-big-picture>1.2 The Big Picture<a hidden class=anchor aria-hidden=true href=#12-the-big-picture>#</a></h2><p>Before we dive deeper let&rsquo;s take a bird&rsquo;s eye view on the ENS. The most fundamental component is the <em>ENS registry</em>, which stores data about names and in particular can determine the responsible <em>resolver</em> for each name. The registry is a single smart contract, but in principle there can be many active resolvers in the system. A resolver fulfills a very similar task as a DNS resolver: When it receives a name, it responds by returning the associated resource, which, in the simplest case would be an Ethereum address. Lastly, there are <em>registrars</em>, which are smart contracts responsible for allocating subdomains. Similar to resolvers, there can be many registrars and they can exist at any level of the hierarchy. For example, if you own the name &ldquo;alice.eth&rdquo; it means you can deploy your very own registrar contract and transfer to it the ownership of your domain. This contract can then be used to issue subdomains of the type <em>x.alice.eth</em> to users and you can freely make up the rules for who gets a subdomain. But since we are getting ahead of ourselves, we will come back to this topic later.</p><h1 id=2-the-core-contracts-of-the-ens>2. The Core Contracts of the ENS<a hidden class=anchor aria-hidden=true href=#2-the-core-contracts-of-the-ens>#</a></h1><h2 id=21-names-and-nodes>2.1 Names and Nodes<a hidden class=anchor aria-hidden=true href=#21-names-and-nodes>#</a></h2><p>The smart contracts of the ENS revolve around the concept of a <strong>node</strong>, which in this context is defined as a hash uniquely identifying a name. A name in turn is an ENS identifier, such as &ldquo;alice.eth&rdquo;, which can be comprised of multiple labels each separated by a dot. That is &ldquo;worm&rdquo; or &ldquo;wen.wide.vitalik.eth&rdquo; are both valid names. Note, that the rightmost label is the equivalent to TLDs in DNS. Currently, &ldquo;worm&rdquo; doesn&rsquo;t exist as a domain name on Ethereum mainnet, but there&rsquo;s nothing in the code to prevent it from existing.</p><p>Now, there are a few caveats to human-readable names when it comes to using them on-chain. In particular, working with strings in Solidity can get messy quite fast and is also not very efficient. Using a hash function to obtain a fixed-length representation of names is therefore the obvious solution. This fixed-length representation of a names is going to be what we called a node above. Since nodes provide the internal representation of names in the ENS we capture their formal definition here.</p><blockquote><p>Definition: A <strong>node</strong> is a bytes32 identifier, which is obtained from an ENS name by first normalising it according to UTS-46 and then applying the Namehash algorithm to it.</p></blockquote><p>At this point, it&rsquo;s not really necessary to know anything about <a href=https://unicode.org/reports/tr46/>Unicode UTS-46</a>, but you should be aware that it exists. Among other things, the normalisation according to UTS-46 checks the names for validity (for example underscores are prohibited) and converts all names to lowercase.</p><p>However, the Namehash algorithm is the heart of the ENS and therefore we have to take a close look at it first. Fortunately for us, its definition is very compact and easy to understand by means of an example. The full scope of its definition is a bit more difficult to understand, but we will come back to it at the appropriate place and by the end of the article you should have become aware of its prominent position in the ENS.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=n>namehash</span><span class=p>([])</span> <span class=o>=</span> <span class=mh>0x0</span>
</span></span><span class=line><span class=cl><span class=n>namehash</span><span class=p>([</span><span class=n>label</span><span class=p>,</span> <span class=err>…</span><span class=p>])</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=n>namehash</span><span class=p>(</span><span class=err>…</span><span class=p>),</span> <span class=nb>keccak256</span><span class=p>(</span><span class=n>label</span><span class=p>))</span>
</span></span></code></pre></div><p>This pseudo-code implementation of Namehash expects a name in list form, i.e. the name is split into its labels using the dot as a separator. An example: &lsquo;vitalik.eth&rsquo; becomes [&lsquo;vitalik&rsquo;, &rsquo;eth&rsquo;], &lsquo;vitalik.wallet.eth&rsquo; becomes [&lsquo;vitalik&rsquo;, &lsquo;wallet&rsquo;, &rsquo;eth&rsquo;] etc. The base case for the recursion is the empty list [] for which the algorithm returns <code>0x0</code> (note: <code>0x0</code> is short for a 32 byte zero). Through recursion implemented in the second line, each label is hashed first and then, starting with the rightmost list entry, the previous calculation is concatenated with the label hash and hashed again. The most basic non-trivial example we can give is the calculation of &rsquo;eth&rsquo;:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=mi>1</span><span class=p>.</span> <span class=n>namehash</span><span class=p>([</span><span class=s>&#39;eth&#39;</span><span class=p>])</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=n>namehash</span><span class=p>([]),</span> <span class=nb>keccak256</span><span class=p>(</span><span class=s>&#39;eth&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=p>.</span> <span class=n>namehash</span><span class=p>([</span><span class=s>&#39;eth&#39;</span><span class=p>])</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=mh>0x0</span><span class=p>,</span> <span class=nb>keccak256</span><span class=p>(</span><span class=s>&#39;eth&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=mi>3</span><span class=p>.</span> <span class=n>namehash</span><span class=p>([</span><span class=s>&#39;eth&#39;</span><span class=p>])</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=mh>0x0</span><span class=p>,</span> <span class=mh>0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>4</span><span class=p>.</span> <span class=n>namehash</span><span class=p>([</span><span class=s>&#39;eth&#39;</span><span class=p>])</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=mh>0x00000000000000000000000000000000000000000000000000000000000000004f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>5</span><span class=p>.</span> <span class=n>namehash</span><span class=p>([</span><span class=s>&#39;eth&#39;</span><span class=p>])</span> <span class=o>=</span> <span class=mh>0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae</span>
</span></span></code></pre></div><p>It&rsquo;s worth highlighting that both normalisation and hashing are processes which are executed off-chain (if possible). Let&rsquo;s finally move on to the actual contracts.</p><h2 id=22-the-ens-registry>2.2 The ENS Registry<a hidden class=anchor aria-hidden=true href=#22-the-ens-registry>#</a></h2><p>The core on-chain component of the ENS is the registry. This smart contract is essentially a record-keeping device.
Every name at every level gets an entry here.</p><p><img loading=lazy src=/img/post-001/img001.png alt="ENS registry"></p><p>This entry contains the owner of the name, the associated resolver, as well as a caching time-to-live (TTL). In the actual smart contract this data is stored by mapping nodes to a struct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Record</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>address</span> <span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>address</span> <span class=n>resolver</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64</span> <span class=n>ttl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>mapping</span> <span class=p>(</span><span class=kt>bytes32</span> <span class=o>=&gt;</span> <span class=n>Record</span><span class=p>)</span> <span class=n>records</span><span class=p>;</span>
</span></span></code></pre></div><p>Let&rsquo;s look at the contract deployment and the first steps after that. The constructor is actually just one line, which saves the contract deployer as the owner of the node <code>0x0</code> in the records mapping:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>constructor</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>records</span><span class=p>[</span><span class=mh>0x0</span><span class=p>].</span><span class=n>owner</span> <span class=o>=</span> <span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Therefore, a new ENS registry starts out with only one record attached to the node <code>0x0</code>. The name &ldquo;node&rdquo; is no coincidence: the ENS name space follows a tree structure and <code>0x0</code> is the root node. Of course, it is not a binary tree, but each &ldquo;TLD name&rdquo; is a child node of <code>0x0</code>. Now, let&rsquo;s see how to register our first name! From the point of view of the root node every new node is a subnode, so we need to inspect the following method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>setSubnodeOwner</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>bytes32</span> <span class=n>label</span><span class=p>,</span> <span class=kt>address</span> <span class=n>owner</span><span class=p>)</span> <span class=k>public</span> <span class=n>authorised</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=k>returns</span><span class=p>(</span><span class=kt>bytes32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bytes32</span> <span class=n>subnode</span> <span class=o>=</span> <span class=nb>keccak256</span><span class=p>(</span><span class=nb>abi</span><span class=p>.</span><span class=nb>encodePacked</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>label</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>_setOwner</span><span class=p>(</span><span class=n>subnode</span><span class=p>,</span> <span class=n>owner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span> <span class=n>NewOwner</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>label</span><span class=p>,</span> <span class=n>owner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>subnode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>First, this function can only be called by the owner of <code>node</code> (guaranteed by the <code>authorised</code> modifier). This is a crucial point of the implementation. Before continuing let&rsquo;s take a look at that modifier:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>modifier</span> <span class=nf>authorised</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>address</span> <span class=n>owner</span> <span class=o>=</span> <span class=n>records</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nb>require</span><span class=p>(</span><span class=n>owner</span> <span class=o>==</span> <span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span> <span class=o>||</span> <span class=n>operators</span><span class=p>[</span><span class=n>owner</span><span class=p>][</span><span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can safely ignore the <code>operators</code> mapping for now, as it&rsquo;s only used to allow another account to manage one&rsquo;s node. The main takeaway is that in the default state of the contract this modifier is only passed, when the <code>msg.sender</code> address is registered in the <code>owner</code> field of <code>node</code>. We&rsquo;ll get to the implications of this shortly.</p><p>Let&rsquo;s continue with <code>setSubnodeOwner</code>. Alongside the parent node we also need to pass the keccak256 hash of the <code>label</code>, as well as the address of the intended <code>owner</code> of the new subnode. Note, that the first line is nothing more as calculating the Namehash of the new subnode. Since <code>node</code> is already namehashed we can calculate it easily in one step. This is followed up by an internal call to <code>_setOwner</code> which registers the new subnode for it&rsquo;s owner:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>_setOwner</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>address</span> <span class=n>owner</span><span class=p>)</span> <span class=k>internal</span> <span class=k>virtual</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>records</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can see, the tree structure is not explicitly captured in the records mapping. The tree hierarchy is only guaranteed by the way Namehash works and that is perfectly sufficient. This is a really elegant and resource-aware solution which serves as a good example of how blockchain development differs from traditional software development.</p><p>In fact, the tree structure encoded in the naming is primarily a hierarchy of access rights. Recall, that the &ldquo;authorised&rdquo; modifier acts at the level of a node and not at the level of the label in question. This means that the owner of a node can use <code>setSubnodeOwner</code> to override any of its subnodes, even if they are not registered as the owner of those subnodes in the registry. Therefore, the owner of <code>0x0</code> has full control over all nodes.</p><p>Now, since we started from a freshly deployed ENS the only <code>node</code> we can pass to <code>setSubnodeOwner</code> is the root node <code>0x0</code>. If we wanted to establish the <code>eth</code> subdomain we first would have to calculate its keccak256 hash,<code>keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0</code>, and pass that as <code>label</code>. Technically, we would have to normalize the label first according to UTS-46, but the string &ldquo;eth&rdquo; is already normalized. In a real application, however, this would be a necessary first step. The <code>owner</code> field is necessary for handing over control over a subnode to an address that is not the ENS registry deployer address.</p><p>That&rsquo;s all we need to know about the registry for now. You can find the whole source code <a href=https://github.com/ensdomains/ens/blob/master/contracts/ENS.sol>here</a>.</p><h2 id=23-resolvers>2.3 Resolvers<a hidden class=anchor aria-hidden=true href=#23-resolvers>#</a></h2><p>In order for a node to be used within ENS, a resolver must be assigned to it. This can only be done by the current owner of the node. To do this, the owner must call the <code>setResolver</code> method of the ENS registry and pass the <code>node</code> as well as the address of the new resolver.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>setResolver</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>address</span> <span class=n>resolver</span><span class=p>)</span> <span class=k>public</span> <span class=k>virtual</span> <span class=k>override</span> <span class=n>authorised</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>emit</span> <span class=n>NewResolver</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>resolver</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>records</span><span class=p>[</span><span class=n>node</span><span class=p>].</span><span class=n>resolver</span> <span class=o>=</span> <span class=n>resolver</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The basic requirement for a resolver contract is that it is ERC-165 compliant, i.e. it implements a <code>supportsInterface</code> method as specified in <a href=https://eips.ethereum.org/EIPS/eip-165>EIP-165</a>. The idea is that a name in ENS can potentially be resolved to many different things (as described in the introduction) and not every resolver needs to implement every possible use case. The first example of a resolver we can give is therefore the <em>empty</em> resolver:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>EmptyResolver</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>supportsInterface</span><span class=p>(</span><span class=kt>bytes4</span> <span class=n>interfaceID</span><span class=p>)</span> <span class=k>public</span> <span class=k>pure</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>interfaceID</span> <span class=o>==</span> <span class=mh>0x01ffc9a7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Okay, that&rsquo;s maybe not very useful. A more instructive, but still quite simple example is an address resolver. In this scenario, owners of a node can link their node to an Ethereum address. Note that this info is stored in a <code>node => address</code> mapping on the level of the resolver and not in the ENS registry.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>SimpleAddrResolver</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ENS</span> <span class=n>ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>mapping</span> <span class=p>(</span><span class=kt>bytes32</span> <span class=o>=&gt;</span> <span class=kt>address</span><span class=p>)</span> <span class=n>addresses</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>modifier</span> <span class=nf>authorised</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=n>isAuthorised</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>constructor</span><span class=p>(</span><span class=n>ENS</span> <span class=n>_ens</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ens</span> <span class=o>=</span> <span class=n>_ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>supportsInterface</span><span class=p>(</span><span class=kt>bytes4</span> <span class=n>interfaceID</span><span class=p>)</span> <span class=k>public</span> <span class=k>pure</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>interfaceID</span> <span class=o>==</span> <span class=mh>0x01ffc9a7</span> <span class=o>||</span> <span class=n>interfaceID</span> <span class=o>==</span> <span class=mh>0x3b3b57de</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>isAuthorised</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=k>internal</span> <span class=k>view</span> <span class=k>returns</span><span class=p>(</span><span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>address</span> <span class=n>owner</span> <span class=o>=</span> <span class=n>ens</span><span class=p>.</span><span class=n>owner</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>owner</span> <span class=o>==</span> <span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>addr</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>address</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>addresses</span><span class=p>[</span><span class=n>node</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>setAddr</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>address</span> <span class=n>addr</span><span class=p>)</span> <span class=k>external</span> <span class=n>authorised</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>addresses</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, with every request to change the mapping of a node to an address (<code>setAddr</code>), the ENS registry is queried for the owner of the respective node. So at this point the registry is incorporated into the process by the address resolver.</p><p>Now we are ready to understand how name to address resolution works in the ENS. The following image from the ENS docs shows the name resolution procedure for &ldquo;foo.eth&rdquo;. First by calling <code>resolver</code> we inquire the ENS registry about the responsible resolver for &ldquo;foo.eth&rdquo;. Afterwards, we ask the received resolver for the Ethereum address for &ldquo;foo.eth&rdquo; by calling <code>addr</code>.</p><p><img loading=lazy src=/img/post-001/img002.png alt=Resolving></p><p>A small side note: It is important to start with the name resolution at the level of the registry, because only the registry knows which resolver is currently responsible for the respective name. Even if you think you already know the correct resolver address, it may have been changed over time or it may even have been part of a phishing attack.</p><p>There are many different kinds of implementations for resolvers, which vary depending on the use case. A common extension of the address resolver mentioned above is to allow support for storing addresses of other block chains. This way, several crypto addresses can be stored for one name at the same time. This is implemented by extending the <code>address</code> mapping to two variables: Given values for <code>node</code> and <code>coinType</code> it yields a bytes-type object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>mapping</span><span class=p>(</span><span class=kt>bytes32</span> <span class=o>=&gt;</span> <span class=kd>mapping</span><span class=p>(</span><span class=kt>uint256</span> <span class=o>=&gt;</span> <span class=kt>bytes</span><span class=p>))</span> <span class=n>addresses</span><span class=p>;</span>
</span></span></code></pre></div><p>The desired <code>coinType</code> follows <a href=https://github.com/satoshilabs/slips/blob/master/slip-0044.md>SLIP-0044</a> and must be specified for the name resolution. Therefore, the getter and setter methods now take the form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>addr</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>uint256</span> <span class=n>coinType</span><span class=p>)</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bytes</span> <span class=k>memory</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>addresses</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>coinType</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nf>setAddr</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>uint256</span> <span class=n>coinType</span><span class=p>,</span> <span class=kt>bytes</span> <span class=k>memory</span> <span class=n>a</span><span class=p>)</span> <span class=k>public</span> <span class=n>authorised</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>addresses</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>coinType</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The EIP165 interface ID for this multicoin <code>addr</code> function is 0xf1cb7e06.</p><p>This concludes our introduction to resolver contracts. For further reading, the chapter on the <a href=https://docs.ens.domains/contract-api-reference/publicresolver>PublicResolver</a> from the official ENS documentation is recommended as a starting point.</p><h2 id=24-registrars>2.4 Registrars<a hidden class=anchor aria-hidden=true href=#24-registrars>#</a></h2><p>We have so far covered the two main components of the Ethereum Name Service. In the section on the registry, we saw that each node owner can in principle create as many subnodes as they wish. In practice, however, the creation of subnodes is typically managed by a smart contract, which can freely specify the conditions for acquiring a subdomain. In particular, this is the case for Top-Level Domains like &ldquo;.eth&rdquo;. These smart contracts are called registrars. By design, each person who owns a domain (on any level) can manage the subdomains themselves, i.e. they can also deploy and use a registrar contract for administration as they wish.</p><p>Let&rsquo;s look at an example. This registrar implementation allows anyone to call <code>register</code>, to obtain a subnode of some fixed parent node. After a period of 4 weeks the subnode will be available for registration again.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>TestRegistrar</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>constant</span> <span class=n>registrationPeriod</span> <span class=o>=</span> <span class=mi>4</span> <span class=kc>weeks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ENS</span> <span class=n>ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bytes32</span> <span class=k>public</span> <span class=n>parentNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>mapping</span> <span class=p>(</span><span class=kt>bytes32</span> <span class=o>=&gt;</span> <span class=kt>uint</span><span class=p>)</span> <span class=k>public</span> <span class=n>expiryTimes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>constructor</span><span class=p>(</span><span class=n>ENS</span> <span class=n>_ens</span><span class=p>,</span> <span class=kt>bytes32</span> <span class=n>_node</span><span class=p>)</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ens</span> <span class=o>=</span> <span class=n>_ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>parentNode</span> <span class=o>=</span> <span class=n>_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>register</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>label</span><span class=p>,</span> <span class=kt>address</span> <span class=n>owner</span><span class=p>)</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=n>expiryTimes</span><span class=p>[</span><span class=n>label</span><span class=p>]</span> <span class=o>&lt;</span> <span class=nb>block</span><span class=p>.</span><span class=nb>timestamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>expiryTimes</span><span class=p>[</span><span class=n>label</span><span class=p>]</span> <span class=o>=</span> <span class=nb>block</span><span class=p>.</span><span class=nb>timestamp</span> <span class=o>+</span> <span class=n>registrationPeriod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ens</span><span class=p>.</span><span class=n>setSubnodeOwner</span><span class=p>(</span><span class=n>parentNode</span><span class=p>,</span> <span class=n>label</span><span class=p>,</span> <span class=n>owner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can see in the last line of the <code>register</code> function, after checking availability the contract just calls <code>setSubnodeOwner</code> at the ENS registry on behalf of the user. For this to work the <code>TestRegistrar</code> contract must hold ownership of <code>parentNode</code>, i.e. the registrar&rsquo;s address must have been stored in the ENS registry for <code>parentNode</code>.</p><p>One especially useful application of registrars is reverse resolution, that is the process of mapping an Ethereum address to an ENS name. On mainnet the <code>ReverseRegistrar</code> implements reverse lookup as an opt-in process. It controls the <code>addr.reverse</code> domain and allows any user to call its <code>setName</code> function in order to have their Ethereum address linked with their domain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>setName</span><span class=p>(</span><span class=kt>string</span> <span class=k>memory</span> <span class=nb>name</span><span class=p>)</span> <span class=k>public</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bytes32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bytes32</span> <span class=n>node</span> <span class=o>=</span> <span class=n>claimWithResolver</span><span class=p>(</span><span class=kt>address</span><span class=p>(</span><span class=nb>this</span><span class=p>),</span> <span class=kt>address</span><span class=p>(</span><span class=n>defaultResolver</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>defaultResolver</span><span class=p>.</span><span class=n>setName</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=nb>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We will not go into all the implementation details here, but describe the process briefly instead. The first line of <code>setName</code> accomplishes two things. First, the calling account is given ownership over the associated reverse ENS record. A reverse ENS record is simply a conventional ENS record which is used for the purpose of reverse resolution. In other words, a caller with the account <code>0x314159265dd8dbb310642f98f50c066173c1259b</code> afterwards owns the subdomain <code>0x314159265dd8dbb310642f98f50c066173c1259b.addr.reverse</code>. Next, a special type of resolver, called a reverse resolver is set as the resolver in the reverse record. Finally, in the second line, the user&rsquo;s provided <code>name</code> is supplied to the <code>setName</code> function of this reverse resolver (called <code>defaultResolver</code> above). The following contract is a simplified version of a reverse resolver.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>ReverseResolver</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ENS</span> <span class=n>ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>mapping</span><span class=p>(</span><span class=kt>bytes32</span><span class=o>=&gt;</span><span class=kt>string</span><span class=p>)</span> <span class=k>public</span> <span class=nb>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>constructor</span><span class=p>(</span><span class=n>ENS</span> <span class=n>_ens</span><span class=p>)</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ens</span> <span class=o>=</span> <span class=n>_ens</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>modifier</span> <span class=nf>owner_only</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>require</span><span class=p>(</span><span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span> <span class=o>==</span> <span class=n>ens</span><span class=p>.</span><span class=n>owner</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>setName</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>,</span> <span class=kt>string</span> <span class=n>calldata</span> <span class=n>_name</span><span class=p>)</span> <span class=k>public</span> <span class=n>owner_only</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>name</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>name</span><span class=p>(</span><span class=kt>bytes32</span> <span class=n>node</span><span class=p>)</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>string</span> <span class=k>memory</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>names</span><span class=p>[</span><span class=n>node</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In summary, reverse resolution works exactly like normal resolution, except that an Ethereum address is used as a label for the subdomain.</p><p>As you can see registrars offer many possibilities to use your ENS domain in creative ways. They complement the functionality of registry and resolvers and are the final part of our presentation of the ENS core contracts.</p><h1 id=3-the-permanent-registrar>3. The Permanent Registrar<a hidden class=anchor aria-hidden=true href=#3-the-permanent-registrar>#</a></h1><p>Whew! Congratulations if you have made it this far - you are already familiar with all the basic components of the Ethereum Name Service. In this final section, we&rsquo;ll have a look at some cool aspects of the <code>.eth</code> Permanent Registrar. This is the smart contract that manages the allocation of <code>.eth</code> domains on the Ethereum mainnet.</p><h2 id=31-eth-domains-are-erc-721-tokens>3.1 .eth Domains are ERC-721 Tokens<a hidden class=anchor aria-hidden=true href=#31-eth-domains-are-erc-721-tokens>#</a></h2><p>Certainly one of the coolest features of the Permanent Registrar is that it&rsquo;s fully ERC-721 compliant, i.e. &ldquo;.eth&rdquo; domains are tradable as NFTs. According to <a href=https://eips.ethereum.org/EIPS/eip-721>EIP-721</a> the identifier of an NFT, its <code>tokenId</code>, must be a <code>uint256</code>. In the implementation of the Permanent Registrar it was decided to use the uint256 representation of the label hashes for the <code>tokenId</code>. Therefore, the contract uses <code>uint256</code> instead of <code>bytes32</code> for labels and then casts back to <code>bytes32</code> when interacting with the registry. In the code snippet below you can see part of the process of registering a domain with the registrar.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>_register</span><span class=p>(</span><span class=kt>uint256</span> <span class=n>id</span><span class=p>,</span> <span class=kt>address</span> <span class=n>owner</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>duration</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>updateRegistry</span><span class=p>)</span> <span class=k>internal</span> <span class=n>live</span> <span class=n>onlyController</span> <span class=k>returns</span><span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>require</span><span class=p>(</span><span class=n>available</span><span class=p>(</span><span class=n>id</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nb>require</span><span class=p>(</span><span class=nb>now</span> <span class=o>+</span> <span class=n>duration</span> <span class=o>+</span> <span class=n>GRACE_PERIOD</span> <span class=o>&gt;</span> <span class=nb>now</span> <span class=o>+</span> <span class=n>GRACE_PERIOD</span><span class=p>);</span> <span class=c1>// Prevent future overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>expiries</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>=</span> <span class=nb>now</span> <span class=o>+</span> <span class=n>duration</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>_exists</span><span class=p>(</span><span class=n>id</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Name was previously owned, and expired
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>_burn</span><span class=p>(</span><span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>_mint</span><span class=p>(</span><span class=n>owner</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>updateRegistry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ens</span><span class=p>.</span><span class=n>setSubnodeOwner</span><span class=p>(</span><span class=n>baseNode</span><span class=p>,</span> <span class=kt>bytes32</span><span class=p>(</span><span class=n>id</span><span class=p>),</span> <span class=n>owner</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>emit</span> <span class=n>NameRegistered</span><span class=p>(</span><span class=n>id</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=nb>now</span> <span class=o>+</span> <span class=n>duration</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>now</span> <span class=o>+</span> <span class=n>duration</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You can also see how the mint and burn processes of the ERC-721 token are handled during (re-)registration. Maybe you also noticed the two modifiers, <code>live</code> and <code>onlyController</code>. The <code>live</code> modifier checks whether the current Permanent Registrar contract is still in use, while the <code>onlyController</code> modifier restricts access for the <code>_register</code> function to registered controllers. Instead of users registering or renewing a domain directly with the Permanent Registrar, this is done via separate Controller smart contracts. The controller contract registers the domain on behalf of the buyer with the Permanent Registrar and afterwards transfers full ownership to them.</p><h2 id=32-reclaiming-ownership-of-a-name>3.2 Reclaiming Ownership of a Name<a hidden class=anchor aria-hidden=true href=#32-reclaiming-ownership-of-a-name>#</a></h2><p>However, not all user requests are handled by the controller. If you somehow lose ownership over your domain&rsquo;s registration at the ENS registry, but are still in possession of your ERC-721 token you can reclaim ownership of your registry records by calling the <code>reclaim</code> function of the Permanent Registrar.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* @dev Reclaim ownership of a name in ENS, if you own it in the registrar.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nf>reclaim</span><span class=p>(</span><span class=kt>uint256</span> <span class=n>id</span><span class=p>,</span> <span class=kt>address</span> <span class=n>owner</span><span class=p>)</span> <span class=k>external</span> <span class=n>live</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>require</span><span class=p>(</span><span class=n>_isApprovedOrOwner</span><span class=p>(</span><span class=nb>msg</span><span class=p>.</span><span class=nb>sender</span><span class=p>,</span> <span class=n>id</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>ens</span><span class=p>.</span><span class=n>setSubnodeOwner</span><span class=p>(</span><span class=n>baseNode</span><span class=p>,</span> <span class=kt>bytes32</span><span class=p>(</span><span class=n>id</span><span class=p>),</span> <span class=n>owner</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As a fully ERC-721 compliant contract the registrar also needs to store all data relevant to the NFT. The <code>reclaim</code> function uses <code>_isApprovedOrOwner</code> to check eligibility. When the check is passed a single call to <code>setSubnodeOwner</code> sets the record straight. The following is an excerpt of OpenZeppelin&rsquo;s ERC-721 implementation as inherited by the Permanent Registrar:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=c1>// Mapping from token ID to owner address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>mapping</span><span class=p>(</span><span class=kt>uint256</span> <span class=o>=&gt;</span> <span class=kt>address</span><span class=p>)</span> <span class=k>private</span> <span class=n>_owners</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Mapping from token ID to approved address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>mapping</span><span class=p>(</span><span class=kt>uint256</span> <span class=o>=&gt;</span> <span class=kt>address</span><span class=p>)</span> <span class=k>private</span> <span class=n>_tokenApprovals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Mapping from owner to operator approvals
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>mapping</span><span class=p>(</span><span class=kt>address</span> <span class=o>=&gt;</span> <span class=kd>mapping</span><span class=p>(</span><span class=kt>address</span> <span class=o>=&gt;</span> <span class=kt>bool</span><span class=p>))</span> <span class=k>private</span> <span class=n>_operatorApprovals</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Returns whether `spender` is allowed to manage `tokenId`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nf>_isApprovedOrOwner</span><span class=p>(</span><span class=kt>address</span> <span class=n>spender</span><span class=p>,</span> <span class=kt>uint256</span> <span class=n>tokenId</span><span class=p>)</span> <span class=k>internal</span> <span class=k>view</span> <span class=k>virtual</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>address</span> <span class=n>owner</span> <span class=o>=</span> <span class=n>ERC721</span><span class=p>.</span><span class=n>ownerOf</span><span class=p>(</span><span class=n>tokenId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>spender</span> <span class=o>==</span> <span class=n>owner</span> <span class=o>||</span> <span class=n>isApprovedForAll</span><span class=p>(</span><span class=n>owner</span><span class=p>,</span> <span class=n>spender</span><span class=p>)</span> <span class=o>||</span> <span class=n>getApproved</span><span class=p>(</span><span class=n>tokenId</span><span class=p>)</span> <span class=o>==</span> <span class=n>spender</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=4-a-small-exercise>4. A Small Exercise<a hidden class=anchor aria-hidden=true href=#4-a-small-exercise>#</a></h1><p>This concludes our little excursion into the smart contracts of the ENS. I would like to dismiss you with a little voluntary exercise: While domains like &ldquo;alice.eth&rdquo; are ERC-721 tokens, this does not apply to their subdomains.</p><ol><li>Why is this the case?</li><li>Think about how you can still convert your subdomains into NFTs. (Hint: Registrar.)</li></ol><p>You can find a solution <a href=https://docs.ens.domains/dapp-developer-guide/ens-as-nft#turning-subdomain-into-nft>here</a> in the ENS documentation.</p><p>*All images are from the official <a href=https://docs.ens.domains/>ENS documentation</a>, where you can also find more detailed information on most topics. Thanks for reading and if you found an error or have further questions please feel free to contact me.
*</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/solidity/>Solidity</a></li><li><a href=http://localhost:1313/tags/ethereum/>Ethereum</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/post-002/><span class=title>« Prev</span><br><span>ZK001: Finite Field Arithmetic in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>