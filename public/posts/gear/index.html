<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Block Authoring in Vara Network | a5xz2</title>
<meta name=keywords content="Vara Network,Substrate,Block Authoring,Polkadot,Rust"><meta name=description content="In this article, we will explore how Vara Network&rsquo;s custom block authoring implementation differs from the native Substrate implementation."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/gear/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/gear/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><meta property="og:title" content="Block Authoring in Vara Network"><meta property="og:description" content="In this article, we will explore how Vara Network&rsquo;s custom block authoring implementation differs from the native Substrate implementation."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/gear/"><meta property="og:image" content="http://localhost:1313/img/gear/VaraNetworkDarkBg.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-24T18:26:43+02:00"><meta property="article:modified_time" content="2024-05-24T18:26:43+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/img/gear/VaraNetworkDarkBg.png"><meta name=twitter:title content="Block Authoring in Vara Network"><meta name=twitter:description content="In this article, we will explore how Vara Network&rsquo;s custom block authoring implementation differs from the native Substrate implementation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Block Authoring in Vara Network","item":"http://localhost:1313/posts/gear/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Block Authoring in Vara Network","name":"Block Authoring in Vara Network","description":"In this article, we will explore how Vara Network\u0026rsquo;s custom block authoring implementation differs from the native Substrate implementation.","keywords":["Vara Network","Substrate","Block Authoring","Polkadot","Rust"],"articleBody":"Block Authoring in Vara Network 1. Introduction Vara Network is a standalone Layer 1 decentralized network built on top of Gear Protocol, which is itself based on Substrate. In this article, we will explore how Gear Protocol’s custom block authoring implementation differs from the native Substrate implementation and how this important enhancement allows for Gear’s message queue feature, a core component of Gear’s Actor model. We will begin by examining Substrate’s block authoring process and then move on to how it is implemented in Gear Protocol.\n2. Block Authoring with Substrate 2.1 The BlockBuilder Utility The BlockBuilder utility is used by the Proposer in the Substrate node as an abstraction over the runtime API to initialize a block, push transactions, and finalize a block. In Substrate, transactions are referred to as extrinsics, which include signed transactions, unsigned transactions, and inherent transactions. The Proposer leverages the BlockBuilder to orchestrate the block production process, ensuring extrinsics are managed and applied correctly, and the block is constructed and finalized properly. Inherent transactions, typically just referred to as inherents, are a special type of unsigned transaction that allows block authoring nodes to add information directly to a block. The block authoring process with the BlockBuilder utility is depicted in the diagram below in a slightly simplified form.\n%%{init: {'theme':'dark'}}%% sequenceDiagram participant Proposer participant BlockBuilder %Proposer-\u003e\u003eBlockBuilder: propose_with() Note over Proposer: Instantiate BlockBuilder Proposer-\u003e\u003eBlockBuilder: activate BlockBuilder Note over Proposer: Applying Inherents Proposer-\u003e\u003eBlockBuilder: BlockBuilder.create_inherents() loop For each inherent Proposer-\u003e\u003eBlockBuilder: BlockBuilder.push(inherent) end deactivate BlockBuilder Note over Proposer: Applying Extrinsics activate BlockBuilder loop For each extrinsic Proposer-\u003e\u003eBlockBuilder: BlockBuilder.estimate_blocksize() Proposer-\u003e\u003eBlockBuilder: BlockBuilder.push(extrinsic) end Note over Proposer: Finalize Block Proposer-\u003e\u003eBlockBuilder: BlockBuilder.build() BlockBuilder--\u003e\u003eProposer: return Block deactivate BlockBuilder The important steps where the Proposer interacts with the BlockBuilder are:\nInitialize BlockBuilder: The Proposer initializes a BlockBuilder with references to the runtime API and necessary state information. Applying Inherents: Inherent extrinsics are created using the create_inherents method and added to the new block using push. Applying Extrinsics: The Proposer then iteratively adds extrinsics from the transaction pool to the block. The BlockBuilder interacts with the runtime API to apply each extrinsic to the blockchain state by calling methods like apply_extrinsic. This ensures each extrinsic can be validly executed before including it in the new block. During this process, the Proposer uses the BlockBuilder’s estimate_blocksize method to monitor the current size of the block. The Proposer stops adding extrinsics if the block size approaches the block size limit or if the consensus deadline is near. Finalize Block: The block is finalized using the build method, which completes the block construction and produces the final block structure ready for inclusion in the blockchain. 2.2 Time and Size Constraints When the Proposer authors a block using the BlockBuilder in Substrate, two key constraints need to be managed: the consensus deadline and the block size limit.\nThe consensus deadline ensures that a block is proposed within a specific timeframe to maintain the overall pace of block production and synchronization across the network. During the block production process, the Proposer monitors the time and ensures that the block is finalized and submitted before the deadline. Additionally, a soft deadline is used as a secondary timing mechanism to decide when to stop attempting to include more extrinsics in a block. The soft deadline is calculated as a percentage of the remaining time until the consensus deadline, providing some flexibility in extrinsics inclusion. This buffer period allows the Proposer to include a few more extrinsics, even if some have been skipped due to size constraints. In this way, the soft deadline ensures that blocks are efficiently filled while adhering to the overall time constraints imposed by the consensus protocol.\nThe block size in Substrate is measured in units of weight. One unit of weight is defined as one picosecond ($10^{-12}$ seconds) of execution time on reference hardware. The total block size limit is further structured by introducing a DispatchClass for extrinsics:\npub enum DispatchClass { Normal, Operational, Mandatory, } The runtime constant NORMAL_DISPATCH_RATIO is set to $80\\%$ by default, meaning that $80\\%$ of the block weight should be comprised of extrinsics of type DispatchClass::Normal. The remaining $20\\%$ can be used by extrinsics of type DispatchClass::Operational and DispatchClass::Mandatory.\nBoth time and block size (i.e., weight) constraints are related because weight is defined as units of computation per time. Therefore, theoretically, it is possible to measure time in terms of weight, and vice versa. However, in practice, this relationship is not perfect, and both approaches are needed together to maintain consistent block production.\n3. Block Authoring with Gear Protocol 3.1 Custom BlockBuilder Implementation In Gear Protocol, there exists a special inherent called Gear::run (also known as the pseudo-inherent), responsible for processing Gear’s message queue. In Gear Protocol, messages serve as the primary interface for communication between actors (users and programs). Each Gear program includes code to handle incoming messages. During message processing, programs can send messages to other programs or users, including replies to the original message. Gear nodes maintain a global message queue. Users can send transactions containing one or more messages to specific programs via a Gear node, which populates the message queue. During block authoring, messages are dequeued and delivered to their respective programs by Gear::run.\nThe Gear::run pseudo-inherent must be added at the end of each block after all other extrinsics have been pushed. To accommodate these requirements, Gear Protocol extends Substrate’s BlockBuilder and Proposer implementations. The diagram below highlights the changes in the block authoring workflow compared to Substrate’s native implementation.\n%%{init: {'theme':'dark'}}%% sequenceDiagram participant Proposer participant BlockBuilder %Proposer-\u003e\u003eBlockBuilder: propose_with() Note over Proposer: Instantiate BlockBuilder Proposer-\u003e\u003eBlockBuilder: activate BlockBuilder Note over Proposer: Applying Inherents Proposer-\u003e\u003eBlockBuilder: BlockBuilder.create_inherents() loop For each inherent Proposer-\u003e\u003eBlockBuilder: BlockBuilder.push(inherent) end deactivate BlockBuilder Note over Proposer: Applying Extrinsics activate BlockBuilder loop For each extrinsic Proposer-\u003e\u003eBlockBuilder: BlockBuilder.estimate_blocksize() Proposer-\u003e\u003eBlockBuilder: BlockBuilder.push(extrinsic) end rect rgb(255,153,0) Note over Proposer: Applying Gear::run Proposer-\u003e\u003eBlockBuilder: BlockBuilder.push_final(max_gas) end Note over Proposer: Building Block Proposer-\u003e\u003eBlockBuilder: BlockBuilder.build() BlockBuilder--\u003e\u003eProposer: return finished Block deactivate BlockBuilder Including the Gear::run inherent in the block is achieved through a new method called push_final, which retrieves the pseudo-inherent using the runtime API and appends it to the end of the block’s list of extrinsics.\npub fn push_final(\u0026mut self, max_gas: Option\u003cu64\u003e) -\u003e Result\u003c(), Error\u003e 3.2 Changes to the Block Structure Since processing the message queue takes a considerable amount of time, Gear Protocol’s block design is adjusted to accommodate this by altering the ratio of extrinsics included in a single block.\nSpecifically, the NORMAL_DISPATCH_RATIO runtime constant is changed from $80\\%$ to $25\\%$, allowing up to $25\\%$ of the block weight to be filled by extrinsics of type DispatchClass::Normal. This adjustment leaves the remaining block weight for extrinsics of DispatchClass::Mandatory and DispatchClass::Operational. However, since there are no DispatchClass::Operational extrinsics in Gear Protocol, Gear::run can effectively utilize up to $75\\%$ of the block’s total weight.\nIn general, we aim to allow Gear::run to occupy this $75\\%$ of the total block. Therefore, an additional constant DEFAULT_GAS_ALLOWANCE for Gear::run is introduced, which accounts for this in units of gas (another representation of weight):\npub const DEFAULT_GAS_ALLOWANCE: u64 = 750_000_000_000; 3.3 Deadline Slippage and max_gas Parameter Since Gear::run assumes it has $75\\%$ of the block’s weight available, a mismatch between the used weight and the actual elapsed time could prevent Gear::run from completing within the current block. In this scenario, the pseudo-inherent would need to be dropped from the current block.\nTo address this, the goal is to provide Gear::run with a realistic approximation of the remaining time available during the block authoring slot. This is achieved by introducing a max_gas parameter, which adjusts for the remaining time in units of gas, as opposed to the DEFAULT_GAS_ALLOWANCE constant.\nAdditionally, a deadline_slippage parameter is introduced, which acts as a “relaxed” version of the NORMAL_DISPATCH_RATIO runtime constant. By default, Substrate allocates $1/3$ of the slot duration for block finalization. Since this time is rarely fully utilized, it is possible to exceed the hard deadline to some degree. For example, a deadline_slippage of $10\\%$ would allow applying extrinsics for $35\\%$ of the block proposal duration. This way, Gear::run can still execute for $75\\%$ of the original proposal duration while exceeding the hard deadline by at most $10\\%$.\n4. Conclusion In summary, the custom block authoring in Gear Protocol utilizing the Gear::run pseudo-inherent provides substantial enhancements to Substrate, with efficient asynchronous messaging and delayed contract execution being just two examples. These advancements open up new and exciting possibilities for dApp development, which users can explore on Vara Network.\n","wordCount":"1403","inLanguage":"en","image":"http://localhost:1313/img/gear/VaraNetworkDarkBg.png","datePublished":"2024-05-24T18:26:43+02:00","dateModified":"2024-05-24T18:26:43+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/gear/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Block Authoring in Vara Network</h1><div class=post-meta><span title='2024-05-24 18:26:43 +0200 CEST'>May 24, 2024</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/gear.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/img/gear/VaraNetworkDarkBg.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-introduction>1. Introduction</a></li><li><a href=#2-block-authoring-with-substrate>2. Block Authoring with Substrate</a><ul><li><a href=#21-the-blockbuilder-utility>2.1 The <code>BlockBuilder</code> Utility</a></li><li><a href=#22-time-and-size-constraints>2.2 Time and Size Constraints</a></li></ul></li><li><a href=#3-block-authoring-with-gear-protocol>3. Block Authoring with <code>Gear Protocol</code></a><ul><li><a href=#31-custom-blockbuilder-implementation>3.1 Custom <code>BlockBuilder</code> Implementation</a></li><li><a href=#32-changes-to-the-block-structure>3.2 Changes to the Block Structure</a></li><li><a href=#33-deadline-slippage-and-max_gas-parameter>3.3 Deadline Slippage and <code>max_gas</code> Parameter</a></li></ul></li><li><a href=#4-conclusion>4. Conclusion</a></li></ul></nav></div></details></div><div class=post-content><h1 id=block-authoring-in-vara-network>Block Authoring in Vara Network<a hidden class=anchor aria-hidden=true href=#block-authoring-in-vara-network>#</a></h1><h2 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h2><p><strong>Vara Network</strong> is a standalone Layer 1 decentralized network built on top of Gear Protocol, which is itself based on Substrate. In this article, we will explore how Gear Protocol&rsquo;s custom block authoring implementation differs from the native Substrate implementation and how this important enhancement allows for Gear&rsquo;s message queue feature, a core component of Gear&rsquo;s <a href=https://wiki.gear-tech.io/docs/gear/technology/actor-model/>Actor model</a>. We will begin by examining Substrate&rsquo;s block authoring process and then move on to how it is implemented in Gear Protocol.</p><h2 id=2-block-authoring-with-substrate>2. Block Authoring with Substrate<a hidden class=anchor aria-hidden=true href=#2-block-authoring-with-substrate>#</a></h2><h3 id=21-the-blockbuilder-utility>2.1 The <code>BlockBuilder</code> Utility<a hidden class=anchor aria-hidden=true href=#21-the-blockbuilder-utility>#</a></h3><p>The <code>BlockBuilder</code> utility is used by the <code>Proposer</code> in the Substrate node as an abstraction over the runtime API to initialize a block, push transactions, and finalize a block. In Substrate, transactions are referred to as extrinsics, which include signed transactions, unsigned transactions, and inherent transactions. The <code>Proposer</code> leverages the <code>BlockBuilder</code> to orchestrate the block production process, ensuring extrinsics are managed and applied correctly, and the block is constructed and finalized properly. Inherent transactions, typically just referred to as inherents, are a special type of unsigned transaction that allows block authoring nodes to add information directly to a block. The block authoring process with the <code>BlockBuilder</code> utility is depicted in the diagram below in a slightly simplified form.</p><pre class=mermaid>%%{init: {'theme':'dark'}}%%
sequenceDiagram
    participant Proposer
    participant BlockBuilder

    %Proposer->>BlockBuilder: propose_with()
    Note over Proposer: Instantiate BlockBuilder
    Proposer->>BlockBuilder: 
    activate BlockBuilder
    Note over Proposer: Applying Inherents
    Proposer->>BlockBuilder: BlockBuilder.create_inherents()
    loop For each inherent
        Proposer->>BlockBuilder: BlockBuilder.push(inherent)
    end
    deactivate BlockBuilder
    Note over Proposer: Applying Extrinsics
    activate BlockBuilder
    loop For each extrinsic
        Proposer->>BlockBuilder: BlockBuilder.estimate_blocksize()
        Proposer->>BlockBuilder: BlockBuilder.push(extrinsic)
    end
    Note over Proposer: Finalize Block
    Proposer->>BlockBuilder: BlockBuilder.build()
    BlockBuilder-->>Proposer: return Block
    deactivate BlockBuilder
</pre><p>The important steps where the <code>Proposer</code> interacts with the <code>BlockBuilder</code> are:</p><ol><li><strong>Initialize BlockBuilder</strong>: The <code>Proposer</code> initializes a <code>BlockBuilder</code> with references to the runtime API and necessary state information.</li><li><strong>Applying Inherents</strong>: Inherent extrinsics are created using the <code>create_inherents</code> method and added to the new block using <code>push</code>.</li><li><strong>Applying Extrinsics</strong>: The <code>Proposer</code> then iteratively adds extrinsics from the transaction pool to the block. The <code>BlockBuilder</code> interacts with the runtime API to apply each extrinsic to the blockchain state by calling methods like <code>apply_extrinsic</code>. This ensures each extrinsic can be validly executed before including it in the new block. During this process, the <code>Proposer</code> uses the <code>BlockBuilder</code>&rsquo;s <code>estimate_blocksize</code> method to monitor the current size of the block. The <code>Proposer</code> stops adding extrinsics if the block size approaches the block size limit or if the consensus deadline is near.</li><li><strong>Finalize Block</strong>: The block is finalized using the <code>build</code> method, which completes the block construction and produces the final block structure ready for inclusion in the blockchain.</li></ol><h3 id=22-time-and-size-constraints>2.2 Time and Size Constraints<a hidden class=anchor aria-hidden=true href=#22-time-and-size-constraints>#</a></h3><p>When the <code>Proposer</code> authors a block using the <code>BlockBuilder</code> in Substrate, two key constraints need to be managed: the consensus deadline and the block size limit.</p><p>The consensus deadline ensures that a block is proposed within a specific timeframe to maintain the overall pace of block production and synchronization across the network. During the block production process, the <code>Proposer</code> monitors the time and ensures that the block is finalized and submitted before the deadline. Additionally, a soft deadline is used as a secondary timing mechanism to decide when to stop attempting to include more extrinsics in a block. The soft deadline is calculated as a percentage of the remaining time until the consensus deadline, providing some flexibility in extrinsics inclusion. This buffer period allows the <code>Proposer</code> to include a few more extrinsics, even if some have been skipped due to size constraints. In this way, the soft deadline ensures that blocks are efficiently filled while adhering to the overall time constraints imposed by the consensus protocol.</p><p>The block size in Substrate is measured in units of <code>weight</code>. One unit of weight is defined as one picosecond ($10^{-12}$ seconds) of execution time on reference hardware. The total block size limit is further structured by introducing a <code>DispatchClass</code> for extrinsics:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>DispatchClass</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Normal</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Operational</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Mandatory</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The runtime constant <code>NORMAL_DISPATCH_RATIO</code> is set to $80\%$ by default, meaning that $80\%$ of the block weight should be comprised of extrinsics of type <code>DispatchClass::Normal</code>. The remaining $20\%$ can be used by extrinsics of type <code>DispatchClass::Operational</code> and <code>DispatchClass::Mandatory</code>.</p><p>Both time and block size (i.e., weight) constraints are related because weight is defined as units of computation per time. Therefore, theoretically, it is possible to measure time in terms of weight, and vice versa. However, in practice, this relationship is not perfect, and both approaches are needed together to maintain consistent block production.</p><h2 id=3-block-authoring-with-gear-protocol>3. Block Authoring with <code>Gear Protocol</code><a hidden class=anchor aria-hidden=true href=#3-block-authoring-with-gear-protocol>#</a></h2><h3 id=31-custom-blockbuilder-implementation>3.1 Custom <code>BlockBuilder</code> Implementation<a hidden class=anchor aria-hidden=true href=#31-custom-blockbuilder-implementation>#</a></h3><p>In Gear Protocol, there exists a special inherent called <code>Gear::run</code> (also known as the pseudo-inherent), responsible for processing Gear&rsquo;s message queue. In Gear Protocol, messages serve as the primary interface for communication between actors (users and programs). Each Gear program includes code to handle incoming messages. During message processing, programs can send messages to other programs or users, including replies to the original message. Gear nodes maintain a global message queue. Users can send transactions containing one or more messages to specific programs via a Gear node, which populates the message queue. During block authoring, messages are dequeued and delivered to their respective programs by <code>Gear::run</code>.</p><p>The <code>Gear::run</code> pseudo-inherent must be added at the end of each block after all other extrinsics have been pushed. To accommodate these requirements, Gear Protocol extends Substrate&rsquo;s <code>BlockBuilder</code> and <code>Proposer</code> implementations. The diagram below highlights the changes in the block authoring workflow compared to Substrate&rsquo;s native implementation.</p><pre class=mermaid>%%{init: {'theme':'dark'}}%%
sequenceDiagram
    participant Proposer
    participant BlockBuilder

    %Proposer->>BlockBuilder: propose_with()
    Note over Proposer: Instantiate BlockBuilder
    Proposer->>BlockBuilder: 
    activate BlockBuilder
    Note over Proposer: Applying Inherents
    Proposer->>BlockBuilder: BlockBuilder.create_inherents()
    loop For each inherent
        Proposer->>BlockBuilder: BlockBuilder.push(inherent)
    end
    deactivate BlockBuilder
    Note over Proposer: Applying Extrinsics
    activate BlockBuilder
    loop For each extrinsic
        Proposer->>BlockBuilder: BlockBuilder.estimate_blocksize()
        Proposer->>BlockBuilder: BlockBuilder.push(extrinsic)
    end
    rect rgb(255,153,0)
    Note over Proposer: Applying Gear::run
    Proposer->>BlockBuilder: BlockBuilder.push_final(max_gas)
    end
    Note over Proposer: Building Block
    Proposer->>BlockBuilder: BlockBuilder.build()
    BlockBuilder-->>Proposer: return finished Block
    deactivate BlockBuilder
</pre><p>Including the <code>Gear::run</code> inherent in the block is achieved through a new method called <code>push_final</code>, which retrieves the pseudo-inherent using the runtime API and appends it to the end of the block&rsquo;s list of extrinsics.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>push_final</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>max_gas</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><h3 id=32-changes-to-the-block-structure>3.2 Changes to the Block Structure<a hidden class=anchor aria-hidden=true href=#32-changes-to-the-block-structure>#</a></h3><p>Since processing the message queue takes a considerable amount of time, Gear Protocol&rsquo;s block design is adjusted to accommodate this by altering the ratio of extrinsics included in a single block.</p><p>Specifically, the <code>NORMAL_DISPATCH_RATIO</code> runtime constant is changed from $80\%$ to $25\%$, allowing up to $25\%$ of the block weight to be filled by extrinsics of type <code>DispatchClass::Normal</code>. This adjustment leaves the remaining block weight for extrinsics of <code>DispatchClass::Mandatory</code> and <code>DispatchClass::Operational</code>. However, since there are no <code>DispatchClass::Operational</code> extrinsics in Gear Protocol, <code>Gear::run</code> can effectively utilize up to $75\%$ of the block&rsquo;s total weight.</p><p><img loading=lazy src=/substrate-vs-gear-block.svg alt=Substrate-vs-Gear-Block></p><p>In general, we aim to allow <code>Gear::run</code> to occupy this $75\%$ of the total block. Therefore, an additional constant <code>DEFAULT_GAS_ALLOWANCE</code> for <code>Gear::run</code> is introduced, which accounts for this in units of gas (another representation of weight):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=no>DEFAULT_GAS_ALLOWANCE</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mi>750_000_000_000</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=33-deadline-slippage-and-max_gas-parameter>3.3 Deadline Slippage and <code>max_gas</code> Parameter<a hidden class=anchor aria-hidden=true href=#33-deadline-slippage-and-max_gas-parameter>#</a></h3><p>Since <code>Gear::run</code> assumes it has $75\%$ of the block&rsquo;s weight available, a mismatch between the used weight and the actual elapsed time could prevent <code>Gear::run</code> from completing within the current block. In this scenario, the pseudo-inherent would need to be dropped from the current block.</p><p>To address this, the goal is to provide <code>Gear::run</code> with a realistic approximation of the remaining time available during the block authoring slot. This is achieved by introducing a <code>max_gas</code> parameter, which adjusts for the remaining time in units of gas, as opposed to the <code>DEFAULT_GAS_ALLOWANCE</code> constant.</p><p>Additionally, a <code>deadline_slippage</code> parameter is introduced, which acts as a &ldquo;relaxed&rdquo; version of the <code>NORMAL_DISPATCH_RATIO</code> runtime constant. By default, Substrate allocates $1/3$ of the slot duration for block finalization. Since this time is rarely fully utilized, it is possible to exceed the hard deadline to some degree. For example, a <code>deadline_slippage</code> of $10\%$ would allow applying extrinsics for $35\%$ of the block proposal duration. This way, <code>Gear::run</code> can still execute for $75\%$ of the original proposal duration while exceeding the hard deadline by at most $10\%$.</p><h2 id=4-conclusion>4. Conclusion<a hidden class=anchor aria-hidden=true href=#4-conclusion>#</a></h2><p>In summary, the custom block authoring in Gear Protocol utilizing the <code>Gear::run</code> pseudo-inherent provides substantial enhancements to Substrate, with efficient asynchronous messaging and delayed contract execution being just two examples. These advancements open up new and exciting possibilities for dApp development, which users can explore on <a href=https://vara.network/>Vara Network</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/vara-network/>Vara Network</a></li><li><a href=http://localhost:1313/tags/substrate/>Substrate</a></li><li><a href=http://localhost:1313/tags/block-authoring/>Block Authoring</a></li><li><a href=http://localhost:1313/tags/polkadot/>Polkadot</a></li><li><a href=http://localhost:1313/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/zkhack-power-corrupts-puzzle/><span class=title>« Prev</span><br><span>ZK Hack - Power Corrupts Puzzle Solution</span>
</a><a class=next href=http://localhost:1313/posts/post-004/><span class=title>Next »</span><br><span>ZK003: Elliptic Curve Arithmetic in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>