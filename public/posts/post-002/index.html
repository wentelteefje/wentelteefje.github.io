<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZK001: Finite Field Arithmetic in Python | a5xz2</title>
<meta name=keywords content="zk-snarks,python,mathematics,groth16"><meta name=description content="In this series of articles we try to implement a toy version of the groth16 zk-snark in python."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/post-002/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e8e1ca2b036c6bcbd582af4b216275873849c35585cc3b2d6e825eca803671c6.css integrity="sha256-6OHKKwNsa8vVgq9LIWJ1hzhJw1WFzDstboJeyoA2ccY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/post-002/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="ZK001: Finite Field Arithmetic in Python"><meta property="og:description" content="In this series of articles we try to implement a toy version of the groth16 zk-snark in python."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/post-002/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-16T15:45:13+02:00"><meta property="article:modified_time" content="2022-08-16T15:45:13+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ZK001: Finite Field Arithmetic in Python"><meta name=twitter:description content="In this series of articles we try to implement a toy version of the groth16 zk-snark in python."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"ZK001: Finite Field Arithmetic in Python","item":"http://localhost:1313/posts/post-002/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZK001: Finite Field Arithmetic in Python","name":"ZK001: Finite Field Arithmetic in Python","description":"In this series of articles we try to implement a toy version of the groth16 zk-snark in python.","keywords":["zk-snarks","python","mathematics","groth16"],"articleBody":"Idea of this series: We try to obtain a solid grasp on current zk-snark protocols by implementing groth16 from the ground up. The field has evolved a lot in the past years and for a part-time project it’s not feasible to come up with a production-grade implementation. The drawback is that we won’t learn much about possible side-channel attacks, but instead we focus more on the mathematical workings of the protocols.\n1. Mathematical Review 1.1 Modular Arithmetic Given an integer $n \u003e 1$, we say two $a,b \\in \\mathbb{Z}$ are congruent modulo $n$, if $n$ is a devisor of their difference, that is if there exists an integer $k$, such that $kn = a - b$. This defines an equivalence relation $\\equiv_n \\subseteq \\mathbb{Z}\\times\\mathbb{Z}$. A little more explicit, this means for any $a,b,c \\in \\mathbb{Z}$:\n$\\equiv_n$ is reflexive: $a \\equiv_n a$, $\\equiv_n$ is symmetric: $a \\equiv_n b$ if and only if $b \\equiv_n a$, $\\equiv_n$ is transitive: If $a \\equiv_n b$ and $b \\equiv_n c$ then $a \\equiv_n c$. More commonly, congruence modulo $n$ is denoted as $a \\equiv b \\pmod{n}$. A few examples: Since $14 - 2 = 12$ which is a multiple of $4$ we have $14 \\equiv 2 \\pmod{4}$ and since $8^2 - 1 = 63$ is a multiple of $3$ we have $8^2 \\equiv 1 \\pmod{3}$. The definition applies to negative integers as well: Since $2-(-3) = 1\\cdot 5$ we have $2 \\equiv -3 \\pmod{5}$ and from $-8-7 = -15 = -3 \\cdot 5$ it follows that $-8 \\equiv 7 \\equiv 2 \\pmod{5}$.\nThe equivalence classes of the congruence relation $\\equiv_n$ are called congruency classes and are comprised of integers congruent modulo $n$. Sticking with the previous examples, here is the congruence class $\\overline{2}$ of 2 modulo 5: $$\\overline{2}_5 = \\lbrace …, -13, -8, -3, 2, 7, 12, 17, …\\rbrace.$$ More generally, for $a \\in \\mathbb{Z}$ its congruence class modulo $n$ is the set $$\\overline{a}_n = \\lbrace a + k\\cdot n\\,|\\,k \\in \\mathbb{Z} \\rbrace.$$\n1.2 Ring of Integers modulo n For a fixed $n \u003e 0$ we collect the congruence classes modulo $n$ in a set $$\\mathbb{Z}/n \\mathbb{Z} := \\lbrace \\overline{a}_n\\,|\\,a \\in \\mathbb{Z} \\rbrace = \\lbrace \\overline{0}_n, \\overline{1}_n, \\overline{2}_n, …, \\overline{n-1}_n \\rbrace$$ and equip it with an addition operation $\\overline{a}_n + \\overline{b}_n := \\overline{a + b}_n$ and a multiplication operation $\\overline{a}_n \\cdot \\overline{b}_n := \\overline{(a \\cdot b)}_n$. Additionally, multiplication is distributive with respect to addition. Together with these two operations the set $\\mathbb{Z}/n\\mathbb{Z}$ is called the ring of integers modulo $n$. Here $(\\mathbb{Z}/n\\mathbb{Z}, +)$ is an abelian group and we can therefore define a subtraction operation as $\\overline{a}_n - \\overline{b}_n := \\overline{(a + (-b))}_n$. However, in general $(\\mathbb{Z}/n\\mathbb{Z}, \\cdot)$ doesn’t have a group structure. Multiplication is associative, commutative and we have a neutral element $\\overline{1}_n$, but not every element has a unique inverse. This is where the trouble starts.\nIt is customary to suppress the distinction of the congruence class and its elements in practice and we will therefore also relax our notation somewhat in the following. That is instead of $\\overline{a}_n$ we are just going to write $a$. An element $a \\in \\mathbb{Z}/n\\mathbb{Z}$ has a multiplicative inverse if and only if $\\gcd(a,n) = 1$ (they are coprime). Elements that have a multiplicative inverse are called units, and they are denoted $a^{-1}$. The set of units is typically denoted as $$(\\mathbb{Z}/n\\mathbb{Z})^{\\times} := \\lbrace a \\in \\mathbb{Z}/n\\mathbb{Z}\\,|\\, a \\textrm{ has an inverse mod n} \\rbrace.$$ Since this set is closed under multiplication, that is the product of two units is again a unit (exercise), it is a group. On the group of units we can finally define a division operation as $a \\cdot b^{-1}$.\n1.3 Finite Fields From the condition for the existence of a multiplicative inverse follows that as soon as $n = p$, for some prime $p$, every element (except for $0$) has such an inverse. That is $$ (\\mathbb{Z}/p\\mathbb{Z})^{\\times} = \\lbrace 1, 2, 3, …, p-1 \\rbrace.$$ Hence, for every prime $p$ the set $\\mathbb{Z}/p\\mathbb{Z}$ together with addition and multiplication fulfils the definition of a (finite) field: A set $F$ equipped with an addition operation $+$ and a multiplication operation $\\cdot$ is called a field, whenever $(F, +)$ is an abelian group (with neutral element $0$), $(F\\setminus{\\lbrace 0\\rbrace}, \\cdot)$ is an abelian group (with neutral element $1$) and $$a\\cdot(b + c) = a\\cdot b + a\\cdot c \\\\ (a + b)\\cdot c = a\\cdot c + a\\cdot c$$ for any $a,b,c \\in F$. So $\\mathbb{Z}/p\\mathbb{Z}$ is a finite field with $p$ elements. We typically denote this field by $\\mathbb{F}_p$ or $GF(p)$ for Galois field (after Évariste Galois, who first introduced finite fields and died in a duel during the French revolution of 1830).\nIn addition to the case described above, for each prime $p$ and every positive integer $k \u003e 1$ there exists a prime field of order $p^k$. Constructing a finite field of order $p^k$ boils down to finding an irreducible polynomial $P$ of degree $k$ over $\\mathbb{F}_p[x]$ and forming the quotient $\\mathbb{F}_p[x]/P$. We are going to describe this procedure more in depth in the next article. Here we are only concerned with the more boring fields obtained from integers.\n2. Python Implementation 2.1 Field methods: Add, Sub, Mult, Div In this article we are going to focus on implementing a convenience class for finite field arithmetic. While our implementation is going to be independent of the exact prime order of the field, we will be working over the prime field $GF(q)$ with $q$ set to\nq = 21888242871839275222246405745257275088696311157297823662689037894645226208583. We have chosen this modulus because the resulting finite field is the basis for the elliptic curves we will implement later. We start by implementing our class by defining:\nclass GFq(): def __init__(self, n): self.n = n % q The idea here is that by wrapping a number in the GFq class automatically reduces it modulo $q$ using Python’s built-in modulo function %. Next, we are going to implement the field operations, i.e. addition, subtraction, multiplication, division as well es exponentiation. Let’s start with addition. One approach would be to define addition as follows.\ndef add(self,other): return GFq(self.n + other.n) This takes two instances of our class and adds their n variables, again wrapping the number in GFq. This approach meets our requirements, but it does not allow us to write field addition using infix notation. Infix notation is the common way of writing an operator between two operands, e.g. 2 + 5. Instead we would have to write GFq(2).add(GFq(5)). Fortunately, Python allows us to overload its built-in operators. This can be achieved by overwriting them in a class. The names of these methods start and end with double underscores. Therefore, we need to alter our method in the following way:\ndef __add__(self,other): return GFq(self.n + other.n) Now we can write GFq(2) + GFq(5) and obtain a correct result. The subtraction and multiplication methods follow the same layout.\ndef __mul__(self, other): return GFq(self.n * other.n) def __sub__(self, other): return GFq(self.n - other.n) Now, since division in prime fields is defined as $a\\cdot b^{-1}$ we need a utility function to find the inverse of any element. The right tool for this task is the extended Euclidean algorithm. For now, we can just copy/paste the pseudo-code from Wikipedia and define a new function as follows.\ndef calc_inverse(a, q): \"\"\"Use the extended Euclidean algorithm to compute the multiplicative inverse\"\"\" (t, newt) = (0, 1) (r, newr) = (q, a) while newr != 0: quotient = r // newr (t, newt) = (newt, t - quotient * newt) (r, newr) = (newr, r - quotient * newr) if r \u003e 1: error(\"a is not invertible!\") if t \u003c 0: t = t + q return t Note, that this function is not a part of our class. With this we can implement the division operation:\ndef __truediv__(self, other): return GFq(self.n * calc_inverse(other.n, q)) def __div__(self, other): return __truediv__(self, other) We overwrite both truediv and div with the same implementation to be able to use the operators / (truediv) and // (div = floor division) interchangeably. The last operation we need to implement is exponentiation.\n2.2 Exponentiation by Squaring The naive approach would be to implement exponentiation simply by successively multiplying the base by itself. However, this yields an inefficient $\\mathcal{O}(n)$ algorithm and with a little work we can do better. As an example, let us compute $4^{118} \\pmod{1000}$. First, write down the binary expansion of the exponent: $$118 = 2^1 + 2^2 + 2^4 + 2^5 + 2^6$$ Now, we can substitute this back to obtain: $$ 4^{118} = 4^{2^1 + 2^2 + 2^4 + 2^5 + 2^6} = 4^{2^1} \\cdot 4^{2^2} \\cdot 4^{2^4} \\cdot 4^{2^5} \\cdot 4^{2^6}$$ The resulting powers $4^{2^i}$ are easily computed as each can be obtained by squaring the preceding power. That is $4^{2^2} = (4^{2^1})^2 = 4^{2\\cdot2^1}$, $4^{2^3} = (4^{2^2})^2$, etc. We can collect the powers in a table like the following.\n$i$ 0 1 2 3 4 5 6 $4^{2^i} \\pmod{1000}$ 4 16 256 536 296 616 456 Using the table we can easily compute the desired quantity: $$4^{118} \\equiv 4^{2^1} \\cdot 4^{2^2} \\cdot 4^{2^4} \\cdot 4^{2^5} \\cdot 4^{2^6} \\equiv 16 \\cdot 256 \\cdot 296 \\cdot 616 \\cdot 456 \\equiv 736 \\pmod{1000}.$$ To create the table we needed 6 multiplications and to get the final result we needed another 4 multiplications, i.e. 10 multiplications in total. If we had followed the naive approach we would have had 117 multiplications. More generally, if we want compute $$g^n = g^{n_0\\cdot 2^0 + n_1\\cdot 2^1 + n_2 \\cdot 2^2 + … + n_r \\cdot 2^r}$$ we need $r$ multiplications to calculate all powers up to $g^{2^r}$. In order to calculate the final result, we need at most another $r$ multiplications. Since $n \\geq 2^r$ we have $\\log_2(n) \\geq r$ and so we obtain a time complexity of $\\mathcal{O}(\\log_2(n))$, i.e. the number of bits in the binary representation of $n$. This algorithm is known as The Fast Powering Algorithm or Exponentiation by Squaring.\nInstead of calculating a table, we implement the algorithm recursively by exploiting the following relationship. $$x^n = \\begin{cases} x(x^{2})^{\\frac {n-1}{2}} \u0026\\text{if $n$ is odd}\\\\ (x^{2})^{\\frac {n}{2}} \u0026\\text{if $n$ is even} \\end{cases}$$\nUsing this formula we can recursively remove the least significant digit of the binary representation of $n$. The full implementation looks like this:\ndef __pow__(self, other): \"\"\"Implements exponentiation by squaring\"\"\" if other == 0: if self != GFq(0): return GFq(1) else: error(\"undefined: 0^0\") elif other == 1: return GFq(self.n) elif other % 2 == 0: return (self * self) ** (other //2) elif other % 2 == 1: return self * (self * self) ** ((other - 1) // 2) 2.3 Overloading Equality and Printing Finally, we want to be able to determine if two elements of our class represent the same element of $GF(q)$. For this we follow the same approach as with the other class methods. We overload == by rewriting the __eq__ method.\ndef __eq__(self, other): \"\"\"Overrides the default implementation\"\"\" if isinstance(other, GFq): return self.n == other.n return NotImplemented The function isinstance(obj, class) returns true if and only if the supplied object obj is an instance of class. Internally, we reduce the problem to checking equality of two integers. Starting with Python3 this implementation already allows us to use != on objects of GFq as well.\nLastly, to aid our intuition we overwrite __str__ to be able to use print():\ndef __str__(self): return str(self.n) ","wordCount":"1895","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-08-16T15:45:13+02:00","dateModified":"2022-08-16T15:45:13+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/post-002/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ZK001: Finite Field Arithmetic in Python</h1><div class=post-meta><span title='2022-08-16 15:45:13 +0200 CEST'>August 16, 2022</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/post-002.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-modular-arithmetic>1.1 Modular Arithmetic</a></li><li><a href=#12-ring-of-integers-modulo-n>1.2 Ring of Integers modulo n</a></li><li><a href=#13-finite-fields>1.3 Finite Fields</a></li></ul><ul><li><a href=#21-field-methods-add-sub-mult-div>2.1 Field methods: Add, Sub, Mult, Div</a></li><li><a href=#22-exponentiation-by-squaring>2.2 Exponentiation by Squaring</a></li><li><a href=#23-overloading-equality-and-printing>2.3 Overloading Equality and Printing</a></li></ul></nav></div></details></div><div class=post-content><p>Idea of this series: We try to obtain a solid grasp on current zk-snark protocols by implementing groth16 from the ground up. The field has evolved a lot in the past years and for a part-time project it&rsquo;s not feasible to come up with a production-grade implementation. The drawback is that we won&rsquo;t learn much about possible side-channel attacks, but instead we focus more on the mathematical workings of the protocols.</p><h1 id=1-mathematical-review>1. Mathematical Review<a hidden class=anchor aria-hidden=true href=#1-mathematical-review>#</a></h1><h2 id=11-modular-arithmetic>1.1 Modular Arithmetic<a hidden class=anchor aria-hidden=true href=#11-modular-arithmetic>#</a></h2><p>Given an integer $n > 1$, we say two $a,b \in \mathbb{Z}$ are congruent modulo $n$, if $n$ is a devisor of their difference, that is if there exists an integer $k$, such that $kn = a - b$. This defines an equivalence relation $\equiv_n \subseteq \mathbb{Z}\times\mathbb{Z}$. A little more explicit, this means for any $a,b,c \in \mathbb{Z}$:</p><ul><li>$\equiv_n$ is reflexive: $a \equiv_n a$,</li><li>$\equiv_n$ is symmetric: $a \equiv_n b$ if and only if $b \equiv_n a$,</li><li>$\equiv_n$ is transitive: If $a \equiv_n b$ and $b \equiv_n c$ then $a \equiv_n c$.</li></ul><p>More commonly, congruence modulo $n$ is denoted as $a \equiv b \pmod{n}$. A few examples: Since $14 - 2 = 12$ which is a multiple of $4$ we have $14 \equiv 2 \pmod{4}$ and since $8^2 - 1 = 63$ is a multiple of $3$ we have $8^2 \equiv 1 \pmod{3}$. The definition applies to negative integers as well: Since $2-(-3) = 1\cdot 5$ we have $2 \equiv -3 \pmod{5}$ and from $-8-7 = -15 = -3 \cdot 5$ it follows that $-8 \equiv 7 \equiv 2 \pmod{5}$.</p><p>The equivalence classes of the congruence relation $\equiv_n$ are called congruency classes and are comprised of integers congruent modulo $n$. Sticking with the previous examples, here is the congruence class $\overline{2}$ of 2 modulo 5:
$$\overline{2}_5 = \lbrace &mldr;, -13, -8, -3, 2, 7, 12, 17, &mldr;\rbrace.$$
More generally, for $a \in \mathbb{Z}$ its congruence class modulo $n$ is the set
$$\overline{a}_n = \lbrace a + k\cdot n\,|\,k \in \mathbb{Z} \rbrace.$$</p><h2 id=12-ring-of-integers-modulo-n>1.2 Ring of Integers modulo n<a hidden class=anchor aria-hidden=true href=#12-ring-of-integers-modulo-n>#</a></h2><p>For a fixed $n > 0$ we collect the congruence classes modulo $n$ in a set
$$\mathbb{Z}/n \mathbb{Z} := \lbrace \overline{a}_n\,|\,a \in \mathbb{Z} \rbrace = \lbrace \overline{0}_n, \overline{1}_n, \overline{2}_n, &mldr;, \overline{n-1}_n \rbrace$$
and equip it with an addition operation $\overline{a}_n + \overline{b}_n := \overline{a + b}_n$ and a multiplication operation $\overline{a}_n \cdot \overline{b}_n := \overline{(a \cdot b)}_n$. Additionally, multiplication is distributive with respect to addition. Together with these two operations the set $\mathbb{Z}/n\mathbb{Z}$ is called the ring of integers modulo $n$. Here $(\mathbb{Z}/n\mathbb{Z}, +)$ is an abelian group and we can therefore define a subtraction operation as $\overline{a}_n - \overline{b}_n := \overline{(a + (-b))}_n$. However, in general $(\mathbb{Z}/n\mathbb{Z}, \cdot)$ doesn&rsquo;t have a group structure. Multiplication is associative, commutative and we have a neutral element $\overline{1}_n$, but not every element has a unique inverse. This is where the trouble starts.</p><p>It is customary to suppress the distinction of the congruence class and its elements in practice and we will therefore also relax our notation somewhat in the following. That is instead of $\overline{a}_n$ we are just going to write $a$. An element $a \in \mathbb{Z}/n\mathbb{Z}$ has a multiplicative inverse if and only if $\gcd(a,n) = 1$ (they are coprime). Elements that have a multiplicative inverse are called units, and they are denoted $a^{-1}$. The set of units is typically denoted as
$$(\mathbb{Z}/n\mathbb{Z})^{\times} := \lbrace a \in \mathbb{Z}/n\mathbb{Z}\,|\, a \textrm{ has an inverse mod n} \rbrace.$$
Since this set is closed under multiplication, that is the product of two units is again a unit (exercise), it is a group. On the group of units we can finally define a division operation as $a \cdot b^{-1}$.</p><h2 id=13-finite-fields>1.3 Finite Fields<a hidden class=anchor aria-hidden=true href=#13-finite-fields>#</a></h2><p>From the condition for the existence of a multiplicative inverse follows that as soon as $n = p$, for some prime $p$, every element (except for $0$) has such an inverse. That is
$$ (\mathbb{Z}/p\mathbb{Z})^{\times} = \lbrace 1, 2, 3, &mldr;, p-1 \rbrace.$$
Hence, for every prime $p$ the set $\mathbb{Z}/p\mathbb{Z}$ together with addition and multiplication fulfils the definition of a (finite) field: A set $F$ equipped with an addition operation $+$ and a multiplication operation $\cdot$ is called a field, whenever $(F, +)$ is an abelian group (with neutral element $0$), $(F\setminus{\lbrace 0\rbrace}, \cdot)$ is an abelian group (with neutral element $1$) and $$a\cdot(b + c) = a\cdot b + a\cdot c \\ (a + b)\cdot c = a\cdot c + a\cdot c$$ for any $a,b,c \in F$. So $\mathbb{Z}/p\mathbb{Z}$ is a finite field with $p$ elements. We typically denote this field by $\mathbb{F}_p$ or $GF(p)$ for Galois field (after Évariste Galois, who first introduced finite fields and died in a duel during the French revolution of 1830).</p><p>In addition to the case described above, for each prime $p$ and every positive integer $k > 1$ there exists a prime field of order $p^k$. Constructing a finite field of order $p^k$ boils down to finding an irreducible polynomial $P$ of degree $k$ over $\mathbb{F}_p[x]$ and forming the quotient $\mathbb{F}_p[x]/P$. We are going to describe this procedure more in depth in the next article. Here we are only concerned with the more boring fields obtained from integers.</p><h1 id=2-python-implementation>2. Python Implementation<a hidden class=anchor aria-hidden=true href=#2-python-implementation>#</a></h1><h2 id=21-field-methods-add-sub-mult-div>2.1 Field methods: Add, Sub, Mult, Div<a hidden class=anchor aria-hidden=true href=#21-field-methods-add-sub-mult-div>#</a></h2><p>In this article we are going to focus on implementing a convenience class for finite field arithmetic. While our implementation is going to be independent of the exact prime order of the field, we will be working over the prime field $GF(q)$ with $q$ set to</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>q</span> <span class=o>=</span> <span class=mf>21888242871839275222246405745257275088696311157297823662689037894645226208583.</span>
</span></span></code></pre></div><p>We have chosen this modulus because the resulting finite field is the basis for the elliptic curves we will implement later. We start by implementing our class by defining:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GFq</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>=</span> <span class=n>n</span> <span class=o>%</span> <span class=n>q</span>
</span></span></code></pre></div><p>The idea here is that by wrapping a number in the <code>GFq</code> class automatically reduces it modulo $q$ using Python&rsquo;s built-in modulo function <code>%</code>. Next, we are going to implement the field operations, i.e. addition, subtraction, multiplication, division as well es exponentiation. Let&rsquo;s start with addition. One approach would be to define addition as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><p>This takes two instances of our class and adds their <code>n</code> variables, again wrapping the number in <code>GFq</code>. This approach meets our requirements, but it does not allow us to write field addition using infix notation. Infix notation is the common way of writing an operator between two operands, e.g. <code>2 + 5</code>. Instead we would have to write <code>GFq(2).add(GFq(5))</code>. Fortunately, Python allows us to overload its built-in operators. This can be achieved by overwriting them in a class. The names of these methods start and end with double underscores. Therefore, we need to alter our method in the following way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__add__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><p>Now we can write <code>GFq(2) + GFq(5)</code> and obtain a correct result. The subtraction and multiplication methods follow the same layout.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__mul__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>*</span> <span class=n>other</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=fm>__sub__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>-</span> <span class=n>other</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><p>Now, since division in prime fields is defined as $a\cdot b^{-1}$ we need a utility function to find the inverse of any element. The right tool for this task is the extended Euclidean algorithm. For now, we can just copy/paste the pseudo-code from Wikipedia and define a new function as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>calc_inverse</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>q</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Use the extended Euclidean algorithm to compute the multiplicative inverse&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>newt</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>newr</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>newr</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>quotient</span> <span class=o>=</span> <span class=n>r</span> <span class=o>//</span> <span class=n>newr</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>newt</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>newt</span><span class=p>,</span> <span class=n>t</span> <span class=o>-</span> <span class=n>quotient</span> <span class=o>*</span> <span class=n>newt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>newr</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>newr</span><span class=p>,</span> <span class=n>r</span> <span class=o>-</span> <span class=n>quotient</span> <span class=o>*</span> <span class=n>newr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>r</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span><span class=p>(</span><span class=s2>&#34;a is not invertible!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>t</span> <span class=o>+</span> <span class=n>q</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>t</span>
</span></span></code></pre></div><p>Note, that this function is not a part of our class. With this we can implement the division operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__truediv__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>*</span> <span class=n>calc_inverse</span><span class=p>(</span><span class=n>other</span><span class=o>.</span><span class=n>n</span><span class=p>,</span> <span class=n>q</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>__div__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=fm>__truediv__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>)</span>
</span></span></code></pre></div><p>We overwrite both truediv and div with the same implementation to be able to use the operators <code>/</code> (truediv) and <code>//</code> (div = floor division) interchangeably. The last operation we need to implement is exponentiation.</p><h2 id=22-exponentiation-by-squaring>2.2 Exponentiation by Squaring<a hidden class=anchor aria-hidden=true href=#22-exponentiation-by-squaring>#</a></h2><p>The naive approach would be to implement exponentiation simply by successively multiplying the base by itself. However, this yields an inefficient $\mathcal{O}(n)$ algorithm and with a little work we can do better. As an example, let us compute $4^{118} \pmod{1000}$. First, write down the binary expansion of the exponent: $$118 = 2^1 + 2^2 + 2^4 + 2^5 + 2^6$$
Now, we can substitute this back to obtain: $$ 4^{118} = 4^{2^1 + 2^2 + 2^4 + 2^5 + 2^6} = 4^{2^1} \cdot 4^{2^2} \cdot 4^{2^4} \cdot 4^{2^5} \cdot 4^{2^6}$$
The resulting powers $4^{2^i}$ are easily computed as each can be obtained by squaring the preceding power. That is $4^{2^2} = (4^{2^1})^2 = 4^{2\cdot2^1}$, $4^{2^3} = (4^{2^2})^2$, etc. We can collect the powers in a table like the following.</p><table><thead><tr><th>$i$</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>$4^{2^i} \pmod{1000}$</td><td>4</td><td>16</td><td>256</td><td>536</td><td>296</td><td>616</td><td>456</td></tr></tbody></table><p>Using the table we can easily compute the desired quantity:
$$4^{118} \equiv 4^{2^1} \cdot 4^{2^2} \cdot 4^{2^4} \cdot 4^{2^5} \cdot 4^{2^6} \equiv 16 \cdot 256 \cdot 296 \cdot 616 \cdot 456 \equiv 736 \pmod{1000}.$$
To create the table we needed 6 multiplications and to get the final result we needed another 4 multiplications, i.e. 10 multiplications in total. If we had followed the naive approach we would have had 117 multiplications. More generally, if we want compute $$g^n = g^{n_0\cdot 2^0 + n_1\cdot 2^1 + n_2 \cdot 2^2 + &mldr; + n_r \cdot 2^r}$$
we need $r$ multiplications to calculate all powers up to $g^{2^r}$. In order to calculate the final result, we need at most another $r$ multiplications. Since $n \geq 2^r$ we have $\log_2(n) \geq r$ and so we obtain a time complexity of $\mathcal{O}(\log_2(n))$, i.e. the number of bits in the binary representation of $n$. This algorithm is known as The Fast Powering Algorithm or Exponentiation by Squaring.</p><p>Instead of calculating a table, we implement the algorithm recursively by exploiting the following relationship.
$$x^n = \begin{cases} x(x^{2})^{\frac {n-1}{2}} &\text{if $n$ is odd}\\ (x^{2})^{\frac {n}{2}} &\text{if $n$ is even} \end{cases}$$</p><p>Using this formula we can recursively remove the least significant digit of the binary representation of $n$. The full implementation looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__pow__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Implements exponentiation by squaring&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>other</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span> <span class=o>!=</span> <span class=n>GFq</span><span class=p>(</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span><span class=p>(</span><span class=s2>&#34;undefined: 0^0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>other</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>GFq</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>other</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=bp>self</span> <span class=o>*</span> <span class=bp>self</span><span class=p>)</span> <span class=o>**</span> <span class=p>(</span><span class=n>other</span> <span class=o>//</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>other</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span> <span class=o>*</span> <span class=p>(</span><span class=bp>self</span> <span class=o>*</span> <span class=bp>self</span><span class=p>)</span> <span class=o>**</span> <span class=p>((</span><span class=n>other</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=23-overloading-equality-and-printing>2.3 Overloading Equality and Printing<a hidden class=anchor aria-hidden=true href=#23-overloading-equality-and-printing>#</a></h2><p>Finally, we want to be able to determine if two elements of our class represent the same element of $GF(q)$. For this we follow the same approach as with the other class methods. We overload <code>==</code> by rewriting the <code>__eq__</code> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__eq__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>GFq</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>==</span> <span class=n>other</span><span class=o>.</span><span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>NotImplemented</span>
</span></span></code></pre></div><p>The function <code>isinstance(obj, class)</code> returns <code>true</code> if and only if the supplied object <code>obj</code> is an instance of <code>class</code>. Internally, we reduce the problem to checking equality of two integers. Starting with Python3 this implementation already allows us to use <code>!=</code> on objects of <code>GFq</code> as well.</p><p>Lastly, to aid our intuition we overwrite <code>__str__</code> to be able to use <code>print()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>str</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/zk-snarks/>Zk-Snarks</a></li><li><a href=http://localhost:1313/tags/python/>Python</a></li><li><a href=http://localhost:1313/tags/mathematics/>Mathematics</a></li><li><a href=http://localhost:1313/tags/groth16/>Groth16</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/post-003/><span class=title>« Prev</span><br><span>ZK002: Extension Field Arithmetic in Python</span>
</a><a class=next href=http://localhost:1313/posts/post-001/><span class=title>Next »</span><br><span>The Smart Contracts of the Ethereum Name Service</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>