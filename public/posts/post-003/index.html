<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZK002: Extension Field Arithmetic in Python | a5xz2</title>
<meta name=keywords content="zk-snarks,python,mathematics,groth16"><meta name=description content="In this part of the series we review and start implementing extension field arithmetic."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/post-003/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e8e1ca2b036c6bcbd582af4b216275873849c35585cc3b2d6e825eca803671c6.css integrity="sha256-6OHKKwNsa8vVgq9LIWJ1hzhJw1WFzDstboJeyoA2ccY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/post-003/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="ZK002: Extension Field Arithmetic in Python"><meta property="og:description" content="In this part of the series we review and start implementing extension field arithmetic."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/post-003/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-19T14:47:32+02:00"><meta property="article:modified_time" content="2022-08-19T14:47:32+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ZK002: Extension Field Arithmetic in Python"><meta name=twitter:description content="In this part of the series we review and start implementing extension field arithmetic."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"ZK002: Extension Field Arithmetic in Python","item":"http://localhost:1313/posts/post-003/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZK002: Extension Field Arithmetic in Python","name":"ZK002: Extension Field Arithmetic in Python","description":"In this part of the series we review and start implementing extension field arithmetic.","keywords":["zk-snarks","python","mathematics","groth16"],"articleBody":"1 Extension Field Arithmetic 1.1 Finite Fields of Prime Power Recall that an irreducible polynomial over a field $K$ is a polynomial which cannot be factored into two non-constant polynomials of lesser degree over $K$ (in much the same way as a prime number cannot be factored into two numbers). For a given prime $p$ and a monic irreducible polynomial $P(x)$ over $\\mathbb{F}_{p}[x]$ of degree $k\\geq 2$, the quotient ring $\\mathbb{F}_p[x]/(P(x))$ is a finite field of order $p^k$. This can be seen by considering that the equivalence classes (cosets) modulo $P(x)$ are given by polynomials of the form $$a_0 + a_1 x + a_2 x^2 + … + a_{k-1}x^{k-1} $$ where $a_i \\in \\mathbb{F}_p$. Since $\\#\\mathbb{F}_p = p$ and there are $k$ separate coefficients $a_i$ this gives $p^k$ different combinations. That the ring $\\mathbb{F}_p/(P(x))$ is indeed a field follows from the fact that $P(x)$ is irreducible.\nLet’s start with a quick example. In the field $\\mathbb{F}_2 = \\lbrace 0, 1 \\rbrace$ we can easily write down the addition and multiplication tables:\n$\\boldsymbol{+}$ $0$ $1$ $\\quad$ $\\boldsymbol{\\times}$ $0$ $1$ $0$ $0$ $1$ $\\quad$ $0$ $0$ $0$ $1$ $1$ $0$ $\\quad$ $1$ $0$ $1$ According to the tables the equation $x^2 + x = 0$ over $\\mathbb{F}_2$ can be solved by $x = 0$ and $x = 1$. This means that we can factor the polynomial as $x^2 + x = (x - 0)(x - 1)$. It is therefore reducible over $\\mathbb{F}_2$. The polynomial $P(x) = x^2 + x + 1$ does not have a root in the field, since $P(0) = P(1) = 1$. Hence, it is irreducible.\nThe quotient $\\mathbb{F}_2[x]/(x^2 + x + 1)$ is a field extension of $\\mathbb{F}_2$ with a root to $P(x)$. It consists of the $2^2 = 4$ elements $0, 1, x, x+1$ and has the addition table:\n$\\boldsymbol{+}$ $0$ $1$ $x$ $x + 1$ $0$ $0$ $1$ $x$ $x+1$ $1$ $1$ $0$ $x+1$ $x +1$ $x$ $x$ $x+1$ $0$ $1$ $x + 1$ $x+1$ $x$ $1$ $0$ Let’s go through the calculation of a few of its entries. Since every polynomial has coefficients from $\\mathbb{F}_2$ we need to keep this fields arithmetic in mind. Therefore, since $2 \\equiv 0 \\pmod{2}$ we have $2x \\equiv 0$, $2(x+1) \\equiv 0$ and $x + x+1 \\equiv 2x + 1 \\equiv 1$. Next, the multiplication table has the form:\n$\\boldsymbol{\\times}$ $0$ $1$ $x$ $x + 1$ $0$ $0$ $0$ $0$ $0$ $1$ $0$ $1$ $x$ $x+1$ $x$ $0$ $x$ $x+1$ $1$ $x + 1$ $0$ $x+1$ $1$ $0$ For $x\\cdot x = x^2$ we know by referring to the polynomial $P$, that $x^2 = -x -1 = -(x +1)$, but $-1 \\equiv 1$ in $\\mathbb{F}_2$, so $x^2 \\equiv x + 1$. Note, how the addition and multiplication tables of $\\mathbb{F}_2$ are embedded in their counterpart in $\\mathbb{F}_2[x]/(x^2 + x + 1)$. This visualises that $\\mathbb{F}_2$ is a subfield of the extension. In this larger field we now have an element $x$ for which $$P(x) = x^2 + x + 1 = (x + 1) + x + 1 = 2(x+1) = 0.$$ This may appear a bit strange at first, since normally a small $x$ denotes a variable and not a concrete element. However, here $x$ is really a new independent element with the property that $P(x) = 0$.\n1.2 Modular Multiplication of Polynomials Let $k := \\operatorname{deg}(P)$ then multiplication of elements $a, b \\in \\mathbb{F}_{p^k} = \\mathbb{F}_{p}[x]/(P(x))$ can be achieved by computing the ordinary polynomial multiplication along with coefficient reductions in $\\mathbb{F}_p$ and a final reduction by the modulus $P$. More explicitly, we can write this multiplication as $$ c(x) = a(x) \\cdot b(x) = \\left( \\sum_{i = 0}^{k-1} a_i x^i \\right) \\cdot \\left( \\sum_{j = 0}^{k-1} b_j x^j \\right) \\equiv \\sum_{l = 0}^{2k-2} c_l x^l \\pmod{P(x)}$$ where $c_l = \\sum_{i + j = l} a_i b_j \\pmod{p}$.\nAs an example we are now going to compute the product $(x + 1)\\cdot (x + 1)$ over $\\mathbb{F}_2[x]/(x^2 + x + 1)$. In the notation of the previous equations we have $a_0 = b_0 = a_1 = b_1 = 1$. Therefore we need to compute $c_l$ for $0 \\leq l \\leq 2k-2 = 2$: $$ \\begin{align*} c_0 \u0026= a_0 b_0 = 1 \u0026\\pmod{2} \\\\ c_1 \u0026= a_0 b_1 + a_1 b_0 = 2 \\equiv 0 \u0026\\pmod{2} \\\\ c_2 \u0026= a_1 b_1 = 1 \u0026\\pmod{2} \\end{align*}$$ This corresponds to the polynomial $c(x) = c_0 x^0 + c_1 x^1 + c_2 x^2 = 1 + x^2$. Now, since $x^2 \\equiv x + 1 \\pmod{P(x)}$ and $2 \\equiv 0 \\pmod{2}$ this polynomial is reduced to $x$.\n1.3 The Field Extensions $\\mathbb{F}_{p^{2}}$ and $\\mathbb{F}_{p^{12}}$ In our implementation of the pairing on elliptic curves we will be working over the fields $\\mathbb{F}_{p^{2}}$ and $\\mathbb{F}_{p^{12}}$. The quadratic extension field will be defined as $\\mathbb{F}_{p^{2}} = \\mathbb{F}_p[x]/(x^2 + 1)$. For this approach to work it is necessary that $x^2 + 1$ is irreducible over $\\mathbb{F}_p$. It is sufficient to choose an odd prime $p$, such that $p \\equiv 3 \\pmod{4}$. Recall, that the multiplicative group $\\mathbb{F}_{p}^{\\times}$ is a cyclic group of order $p - 1$. If $p \\equiv 1 \\pmod{4}$, then $4|(p-1)$ and therefore $\\mathbb{F}_{p}^{\\times}$ has an element $i$ of order $4$, that is $i^4 = 1$ and $i^2 = -1$. Hence, $$x^2 + 1 = (x - i)(x + i)$$ is reducible. The requirement $p \\equiv 3 \\pmod{4}$ precisely prevents the existence of an element of order $4$ in $\\mathbb{F}_{p}^{\\times}$.\nFor $\\mathbb{F}_{p^{12}}$ it’s a bit more complicated. Recall, that an element $\\zeta \\in K$ of a field $K$ is called an $n$-th root of unity, if $\\zeta^n = 1$. Equivalently, this means $\\zeta$ is a root of $X^n - 1$ over $K$. We say $\\zeta$ is primitive if no smaller power accomplishes this.\nNow, consider the polynomial $X^6 - \\zeta$ with some $\\zeta \\in \\mathbb{F}_{p^2}$. Suppose $\\zeta$ is a cube, that is there exists some element $a \\in \\mathbb{F}_{p^2}$, such that $a^3 = \\zeta$. Then $$ X^6 - \\zeta = X^6 - a^3 = (X^2 - a)(X^4 + aX^2 + a^2)$$ and $X^6 - \\zeta$ is not irreducible. Likewise, consider the case where $\\zeta$ is a square, i.e. there exists an element $b$ with $b^2 = \\zeta$. In this case $X^6 - \\zeta$ is also irreducible because $$ X^6 - \\zeta = (X^3)^2 - a^2 = (X^3 - a)(X^3 + a).$$\nTheory: $6|(p^2-1)$ and $6 = 2\\cdot 3$, i.e. $2$ and $3$ both devide $p^2-1$ so only squares and cubes can exist in the field but not biquadrats.\nTherefore the polynomial $(x^6 - 9)^2 + 1 = x^{12} - 18x^6 + 82$ is irreducible over $\\mathbb{F}_p$ and we have $$\\mathbb{F}_{p^{12}} = \\mathbb{F}_p[x]/(x^{12} - 18x^6 + 82).$$\n2. Implementation 2.1 Base Class for Polynomials We start by implementing a base class for polynomial extension field arithmetic, which we later on use to define our quadratic extension field. Knowing a polynomial is knowing its coefficients and therefore an object of this class is represented by the vector (list) of its coefficients. The only other important information is of course the coefficients of the modulus.\nclass PolyExtF(): def __init__(self, coeffs, modulus_coeffs): assert len(coeffs) == len(modulus_coeffs) self.coeffs = coeffs self.degree = len(self.modulus_coeffs) self.modulus_coeffs = modulus_coeffs We agree on the convention that the least significant coefficients are on the left side of the vector, that is the polynomial $Q(x) = \\sum_{i = 0}^{k-1} a_i x^i$ is represented by the vector $(a_0, a_1, …, a_{k-2}, a_{k-1})$. Additionally, since the modulus is the only polynomial of degree $k$ and its leading coefficient $a_k$ will always be equal to one, we don’t save $a_k$ in modulus_coeffs vector. This way we can represent the modulus by a vector of length $k-1$ like all the other elements of the field. Of course we need to remember this implied $a_k = 1$ in the algorithms we are going to implement, but in the end it will save us some overhead.\n2.2 Modular Addition and Subtraction Since there’s no reduction mod $P$ needed, both addition and subtraction are easy to implement. We illustrate this with the example of addition. Let $a,b \\in \\mathbb{F}_{p}[x]/(P(x))$ then\n$$ a(x) + b(x) = \\sum_{i = 0}^{k - 1} c_i x^i,$$ where $c_i = (a_i + b_i) \\pmod{p}$. Therefore, we only need to reduce the coefficient $c_i$ modulo $p$ when $a_i + b_i \\geq p$. Just as we did in the case of the base field $\\mathbb{F}_{p}$, we overload Python’s operands $+$ and $-$ by overwriting the methods __add__ and __sub__.\ndef __add__(self, other): assert self.deg == other.deg return PolyExtF([ a + b for a,b in zip(self.coeffs,other.coeffs)]) def __sub__(self, other): assert self.deg == other.deg return PolyExtF([ a - b for a,b in zip(self.coeffs,other.coeffs)]) 2.3 Modular Multiplication This one is a bit trickier, but we have already laid most of the groundwork in the introduction. We break this one into two parts. First, we implement the computation of the $c_l$, then we think about how to reduce the resulting polynomial modulo $P$.\nA multiplication of two polynomials with degree at most $k - 1$ results in a new polynomial of degree at most $2k -2$. Therefore we start by initialising a coefficient vector of length $2k - 2 + 1$, then we use two for loops to calculate the $c_l$:\nk = self.deg c = [GFq(0)] * (2*k - 1) for i in range(k): for j in range(k): c[i+j] += a[i] * b[j] Now, starting with the most significant coefficient we reduce the $c_l$ via the modulus coefficients until only terms of degree at most $k-1$ remain.\n# Reduction part while len(c) \u003e k: exp = len(c) - k - 1 top = c.pop() for i in range(k): c[exp + i] -= top * modulus_coeffs[i] return c This is really just like polynomial long division except that we only keep track of the remainder. As an example consider the product of the polynomials $u(x) = 2x^2 +x + 2$ and $v(x) = x^2 + 2x$ modulo $x^3 + 1$. A traditional long division of the product $u(x)v(x)$ modulo $x^3 + 1$ looks like this:\n$$\\begin{align*} (2x^4\u0026 +\u0026 5x^3\u0026 +\u0026 4x^2\u0026 +\u0026 4x\u0026 +\u0026 0\u0026):(x^3 + 1) = 2x + 5\\\\ -(3x^4\u0026\u0026 \u0026\u0026 \u0026 +\u0026 2x\u0026\u0026\u0026) \\\\ \u0026\u0026(5x^3\u0026 +\u00264x^2\u0026 +\u0026 2x\u0026 +\u0026 0\u0026) \\\\ \u0026\u0026-(5x^3\u0026 \u0026\u0026 \u0026 \u0026 +\u0026 5\u0026) \\\\ \u0026\u0026\u0026\u0026( 4x^2\u0026+\u0026 2x\u0026 -\u0026 5\u0026) \\\\ \\end{align*}$$ If we compare the coefficients with the intermediate results of the reduction algorithm, we see that each pass of the inner loop corresponds to one step of the polynomial division:\nInput: c = [0, 4, 4, 5, 2] After Loop 1: c = [0, 2, 4, 5] After Loop 2: c = [-5, 2, 4] TODO: Take care of base field modulus reduction.\nReferences [1] Mrabet, N.E., \u0026 Joye, M. (Eds.). (2016). Guide to Pairing-Based Cryptography (1st ed.). Chapman and Hall/CRC. https://doi.org/10.1201/9781315370170\n[2] Barreto, P.S.L.M., Naehrig, M. (2006). Pairing-Friendly Elliptic Curves of Prime Order. In: Preneel, B., Tavares, S. (eds) Selected Areas in Cryptography. SAC 2005. Lecture Notes in Computer Science, vol 3897. Springer, Berlin, Heidelberg. https://doi.org/10.1007/11693383_22\n","wordCount":"1831","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-08-19T14:47:32+02:00","dateModified":"2022-08-19T14:47:32+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/post-003/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/publications/ title=publications><span>publications</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ZK002: Extension Field Arithmetic in Python</h1><div class=post-meta><span title='2022-08-19 14:47:32 +0200 CEST'>August 19, 2022</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/post-003.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-finite-fields-of-prime-power>1.1 Finite Fields of Prime Power</a></li><li><a href=#12-modular-multiplication-of-polynomials>1.2 Modular Multiplication of Polynomials</a></li><li><a href=#13-the-field-extensions-mathbbf_p2-and-mathbbf_p12>1.3 The Field Extensions $\mathbb{F}_{p^{2}}$ and $\mathbb{F}_{p^{12}}$</a></li></ul><ul><li><a href=#21-base-class-for-polynomials>2.1 Base Class for Polynomials</a></li><li><a href=#22-modular-addition-and-subtraction>2.2 Modular Addition and Subtraction</a></li><li><a href=#23-modular-multiplication>2.3 Modular Multiplication</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-extension-field-arithmetic>1 Extension Field Arithmetic<a hidden class=anchor aria-hidden=true href=#1-extension-field-arithmetic>#</a></h1><h2 id=11-finite-fields-of-prime-power>1.1 Finite Fields of Prime Power<a hidden class=anchor aria-hidden=true href=#11-finite-fields-of-prime-power>#</a></h2><p>Recall that an irreducible polynomial over a field $K$ is a polynomial which cannot be factored into two non-constant polynomials of lesser degree over $K$ (in much the same way as a prime number cannot be factored into two numbers). For a given prime $p$ and a monic irreducible polynomial $P(x)$ over $\mathbb{F}_{p}[x]$ of degree $k\geq 2$, the quotient ring $\mathbb{F}_p[x]/(P(x))$ is a finite field of order $p^k$. This can be seen by considering that the equivalence classes (cosets) modulo $P(x)$ are given by polynomials of the form
$$a_0 + a_1 x + a_2 x^2 + &mldr; + a_{k-1}x^{k-1} $$
where $a_i \in \mathbb{F}_p$. Since $\#\mathbb{F}_p = p$ and there are $k$ separate coefficients $a_i$ this gives $p^k$ different combinations. That the ring $\mathbb{F}_p/(P(x))$ is indeed a field follows from the fact that $P(x)$ is irreducible.</p><p>Let&rsquo;s start with a quick example. In the field $\mathbb{F}_2 = \lbrace 0, 1 \rbrace$ we can easily write down the addition and multiplication tables:</p><table><thead><tr><th>$\boldsymbol{+}$</th><th>$0$</th><th>$1$</th><th>$\quad$</th><th>$\boldsymbol{\times}$</th><th>$0$</th><th>$1$</th></tr></thead><tbody><tr><td>$0$</td><td>$0$</td><td>$1$</td><td>$\quad$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$1$</td><td>$1$</td><td>$0$</td><td>$\quad$</td><td>$1$</td><td>$0$</td><td>$1$</td></tr></tbody></table><p>According to the tables the equation $x^2 + x = 0$ over $\mathbb{F}_2$ can be solved by $x = 0$ and $x = 1$. This means that we can factor the polynomial as $x^2 + x = (x - 0)(x - 1)$. It is therefore reducible over $\mathbb{F}_2$. The polynomial $P(x) = x^2 + x + 1$ does not have a root in the field, since $P(0) = P(1) = 1$. Hence, it is irreducible.</p><p>The quotient $\mathbb{F}_2[x]/(x^2 + x + 1)$ is a field extension of $\mathbb{F}_2$ with a root to $P(x)$. It consists of the $2^2 = 4$ elements $0, 1, x, x+1$ and has the addition table:</p><table><thead><tr><th>$\boldsymbol{+}$</th><th>$0$</th><th>$1$</th><th>$x$</th><th>$x + 1$</th></tr></thead><tbody><tr><td>$0$</td><td>$0$</td><td>$1$</td><td>$x$</td><td>$x+1$</td></tr><tr><td>$1$</td><td>$1$</td><td>$0$</td><td>$x+1$</td><td>$x +1$</td></tr><tr><td>$x$</td><td>$x$</td><td>$x+1$</td><td>$0$</td><td>$1$</td></tr><tr><td>$x + 1$</td><td>$x+1$</td><td>$x$</td><td>$1$</td><td>$0$</td></tr></tbody></table><p>Let&rsquo;s go through the calculation of a few of its entries. Since every polynomial has coefficients from $\mathbb{F}_2$ we need to keep this fields arithmetic in mind. Therefore, since $2 \equiv 0 \pmod{2}$ we have $2x \equiv 0$, $2(x+1) \equiv 0$ and $x + x+1 \equiv 2x + 1 \equiv 1$. Next, the multiplication table has the form:</p><table><thead><tr><th>$\boldsymbol{\times}$</th><th>$0$</th><th>$1$</th><th>$x$</th><th>$x + 1$</th></tr></thead><tbody><tr><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td><td>$0$</td></tr><tr><td>$1$</td><td>$0$</td><td>$1$</td><td>$x$</td><td>$x+1$</td></tr><tr><td>$x$</td><td>$0$</td><td>$x$</td><td>$x+1$</td><td>$1$</td></tr><tr><td>$x + 1$</td><td>$0$</td><td>$x+1$</td><td>$1$</td><td>$0$</td></tr></tbody></table><p>For $x\cdot x = x^2$ we know by referring to the polynomial $P$, that $x^2 = -x -1 = -(x +1)$, but $-1 \equiv 1$ in $\mathbb{F}_2$, so $x^2 \equiv x + 1$. Note, how the addition and multiplication tables of $\mathbb{F}_2$ are embedded in their counterpart in $\mathbb{F}_2[x]/(x^2 + x + 1)$. This visualises that $\mathbb{F}_2$ is a subfield of the extension. In this larger field we now have an element $x$ for which
$$P(x) = x^2 + x + 1 = (x + 1) + x + 1 = 2(x+1) = 0.$$
This may appear a bit strange at first, since normally a small $x$ denotes a variable and not a concrete element. However, here $x$ is really a new independent element with the property that $P(x) = 0$.</p><h2 id=12-modular-multiplication-of-polynomials>1.2 Modular Multiplication of Polynomials<a hidden class=anchor aria-hidden=true href=#12-modular-multiplication-of-polynomials>#</a></h2><p>Let $k := \operatorname{deg}(P)$ then multiplication of elements $a, b \in \mathbb{F}_{p^k} = \mathbb{F}_{p}[x]/(P(x))$ can be achieved by computing the ordinary polynomial multiplication along with coefficient reductions in $\mathbb{F}_p$ and a final reduction by the modulus $P$. More explicitly, we can write this multiplication as
$$ c(x) = a(x) \cdot b(x) = \left( \sum_{i = 0}^{k-1} a_i x^i \right) \cdot \left( \sum_{j = 0}^{k-1} b_j x^j \right) \equiv \sum_{l = 0}^{2k-2} c_l x^l \pmod{P(x)}$$
where $c_l = \sum_{i + j = l} a_i b_j \pmod{p}$.</p><p>As an example we are now going to compute the product $(x + 1)\cdot (x + 1)$ over $\mathbb{F}_2[x]/(x^2 + x + 1)$. In the notation of the previous equations we have $a_0 = b_0 = a_1 = b_1 = 1$. Therefore we need to compute $c_l$ for $0 \leq l \leq 2k-2 = 2$:
$$ \begin{align*} c_0 &= a_0 b_0 = 1 &\pmod{2} \\
c_1 &= a_0 b_1 + a_1 b_0 = 2 \equiv 0 &\pmod{2} \\
c_2 &= a_1 b_1 = 1 &\pmod{2} \end{align*}$$
This corresponds to the polynomial $c(x) = c_0 x^0 + c_1 x^1 + c_2 x^2 = 1 + x^2$. Now, since $x^2 \equiv x + 1 \pmod{P(x)}$ and $2 \equiv 0 \pmod{2}$ this polynomial is reduced to $x$.</p><h2 id=13-the-field-extensions-mathbbf_p2-and-mathbbf_p12>1.3 The Field Extensions $\mathbb{F}_{p^{2}}$ and $\mathbb{F}_{p^{12}}$<a hidden class=anchor aria-hidden=true href=#13-the-field-extensions-mathbbf_p2-and-mathbbf_p12>#</a></h2><p>In our implementation of the pairing on elliptic curves we will be working over the fields $\mathbb{F}_{p^{2}}$ and $\mathbb{F}_{p^{12}}$. The quadratic extension field will be defined as $\mathbb{F}_{p^{2}} = \mathbb{F}_p[x]/(x^2 + 1)$. For this approach to work it is necessary that $x^2 + 1$ is irreducible over $\mathbb{F}_p$. It is sufficient to choose an odd prime $p$, such that $p \equiv 3 \pmod{4}$. Recall, that the multiplicative group $\mathbb{F}_{p}^{\times}$ is a cyclic group of order $p - 1$. If $p \equiv 1 \pmod{4}$, then $4|(p-1)$ and therefore $\mathbb{F}_{p}^{\times}$ has an element $i$ of order $4$, that is $i^4 = 1$ and $i^2 = -1$. Hence, $$x^2 + 1 = (x - i)(x + i)$$ is reducible. The requirement $p \equiv 3 \pmod{4}$ precisely prevents the existence of an element of order $4$ in $\mathbb{F}_{p}^{\times}$.</p><p>For $\mathbb{F}_{p^{12}}$ it&rsquo;s a bit more complicated. Recall, that an element $\zeta \in K$ of a field $K$ is called an $n$-th root of unity, if $\zeta^n = 1$. Equivalently, this means $\zeta$ is a root of $X^n - 1$ over $K$. We say $\zeta$ is primitive if no smaller power accomplishes this.</p><p>Now, consider the polynomial $X^6 - \zeta$ with some $\zeta \in \mathbb{F}_{p^2}$. Suppose $\zeta$ is a cube, that is there exists some element $a \in \mathbb{F}_{p^2}$, such that $a^3 = \zeta$. Then
$$ X^6 - \zeta = X^6 - a^3 = (X^2 - a)(X^4 + aX^2 + a^2)$$
and $X^6 - \zeta$ is not irreducible. Likewise, consider the case where $\zeta$ is a square, i.e. there exists an element $b$ with $b^2 = \zeta$. In this case $X^6 - \zeta$ is also irreducible because
$$ X^6 - \zeta = (X^3)^2 - a^2 = (X^3 - a)(X^3 + a).$$</p><p>Theory: $6|(p^2-1)$ and $6 = 2\cdot 3$, i.e. $2$ and $3$ both devide $p^2-1$ so only squares and cubes can exist in the field but not biquadrats.</p><p>Therefore the polynomial $(x^6 - 9)^2 + 1 = x^{12} - 18x^6 + 82$ is irreducible over $\mathbb{F}_p$ and we have
$$\mathbb{F}_{p^{12}} = \mathbb{F}_p[x]/(x^{12} - 18x^6 + 82).$$</p><h1 id=2-implementation>2. Implementation<a hidden class=anchor aria-hidden=true href=#2-implementation>#</a></h1><h2 id=21-base-class-for-polynomials>2.1 Base Class for Polynomials<a hidden class=anchor aria-hidden=true href=#21-base-class-for-polynomials>#</a></h2><p>We start by implementing a base class for polynomial extension field arithmetic, which we later on use to define our quadratic extension field. Knowing a polynomial is knowing its coefficients and therefore an object of this class is represented by the vector (list) of its coefficients. The only other important information is of course the coefficients of the modulus.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>PolyExtF</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>coeffs</span><span class=p>,</span> <span class=n>modulus_coeffs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>coeffs</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>modulus_coeffs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>coeffs</span> <span class=o>=</span> <span class=n>coeffs</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>degree</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>modulus_coeffs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>modulus_coeffs</span> <span class=o>=</span> <span class=n>modulus_coeffs</span>
</span></span></code></pre></div><p>We agree on the convention that the least significant coefficients are on the left side of the vector, that is the polynomial $Q(x) = \sum_{i = 0}^{k-1} a_i x^i$ is represented by the vector $(a_0, a_1, &mldr;, a_{k-2}, a_{k-1})$. Additionally, since the modulus is the only polynomial of degree $k$ and its leading coefficient $a_k$ will always be equal to one, we don&rsquo;t save $a_k$ in <code>modulus_coeffs</code> vector. This way we can represent the modulus by a vector of length $k-1$ like all the other elements of the field. Of course we need to remember this implied $a_k = 1$ in the algorithms we are going to implement, but in the end it will save us some overhead.</p><h2 id=22-modular-addition-and-subtraction>2.2 Modular Addition and Subtraction<a hidden class=anchor aria-hidden=true href=#22-modular-addition-and-subtraction>#</a></h2><p>Since there&rsquo;s no reduction mod $P$ needed, both addition and subtraction are easy to implement. We illustrate this with the example of addition. Let $a,b \in \mathbb{F}_{p}[x]/(P(x))$ then</p><p>$$ a(x) + b(x) = \sum_{i = 0}^{k - 1} c_i x^i,$$
where $c_i = (a_i + b_i) \pmod{p}$. Therefore, we only need to reduce the coefficient $c_i$ modulo $p$ when $a_i + b_i \geq p$. Just as we did in the case of the base field $\mathbb{F}_{p}$, we overload Python&rsquo;s operands $+$ and $-$ by overwriting the methods <code>__add__</code> and <code>__sub__</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=fm>__add__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=bp>self</span><span class=o>.</span><span class=n>deg</span> <span class=o>==</span> <span class=n>other</span><span class=o>.</span><span class=n>deg</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>PolyExtF</span><span class=p>([</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=k>for</span> <span class=n>a</span><span class=p>,</span><span class=n>b</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>coeffs</span><span class=p>,</span><span class=n>other</span><span class=o>.</span><span class=n>coeffs</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=fm>__sub__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=bp>self</span><span class=o>.</span><span class=n>deg</span> <span class=o>==</span> <span class=n>other</span><span class=o>.</span><span class=n>deg</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>PolyExtF</span><span class=p>([</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span> <span class=k>for</span> <span class=n>a</span><span class=p>,</span><span class=n>b</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>coeffs</span><span class=p>,</span><span class=n>other</span><span class=o>.</span><span class=n>coeffs</span><span class=p>)])</span>
</span></span></code></pre></div><h2 id=23-modular-multiplication>2.3 Modular Multiplication<a hidden class=anchor aria-hidden=true href=#23-modular-multiplication>#</a></h2><p>This one is a bit trickier, but we have already laid most of the groundwork in the introduction. We break this one into two parts. First, we implement the computation of the $c_l$, then we think about how to reduce the resulting polynomial modulo $P$.</p><p>A multiplication of two polynomials with degree at most $k - 1$ results in a new polynomial of degree at most $2k -2$. Therefore we start by initialising a coefficient vector of length $2k - 2 + 1$, then we use two for loops to calculate the $c_l$:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>deg</span>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=p>[</span><span class=n>GFq</span><span class=p>(</span><span class=mi>0</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>b</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span></code></pre></div><p>Now, starting with the most significant coefficient we reduce the $c_l$ via the modulus coefficients until only terms of degree at most $k-1$ remain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Reduction part</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>exp</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>-</span> <span class=n>k</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>top</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>[</span><span class=n>exp</span> <span class=o>+</span> <span class=n>i</span><span class=p>]</span> <span class=o>-=</span> <span class=n>top</span> <span class=o>*</span> <span class=n>modulus_coeffs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>c</span>
</span></span></code></pre></div><p>This is really just like polynomial long division except that we only keep track of the remainder. As an example consider the product of the polynomials $u(x) = 2x^2 +x + 2$ and $v(x) = x^2 + 2x$ modulo $x^3 + 1$. A traditional long division of the product $u(x)v(x)$ modulo $x^3 + 1$ looks like this:</p><p>$$\begin{align*} (2x^4& +& 5x^3& +& 4x^2& +& 4x& +& 0&):(x^3 + 1) = 2x + 5\\
-(3x^4&& && & +& 2x&&&) \\
&&(5x^3& +&amp;4x^2& +& 2x& +& 0&) \\
&&-(5x^3& && & & +& 5&) \\
&&&&( 4x^2&+& 2x& -& 5&) \\
\end{align*}$$
If we compare the coefficients with the intermediate results of the reduction algorithm, we see that each pass of the inner loop corresponds to one step of the polynomial division:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>Input</span><span class=p>:</span> <span class=n>c</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>After</span> <span class=n>Loop</span> <span class=mi>1</span><span class=p>:</span> <span class=n>c</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>After</span> <span class=n>Loop</span> <span class=mi>2</span><span class=p>:</span> <span class=n>c</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span></code></pre></div><p>TODO: Take care of base field modulus reduction.</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>[1] Mrabet, N.E., & Joye, M. (Eds.). (2016). Guide to Pairing-Based Cryptography (1st ed.). Chapman and Hall/CRC. <a href=https://doi.org/10.1201/9781315370170>https://doi.org/10.1201/9781315370170</a></p><p>[2] Barreto, P.S.L.M., Naehrig, M. (2006). Pairing-Friendly Elliptic Curves of Prime Order. In: Preneel, B., Tavares, S. (eds) Selected Areas in Cryptography. SAC 2005. Lecture Notes in Computer Science, vol 3897. Springer, Berlin, Heidelberg. <a href=https://doi.org/10.1007/11693383_22>https://doi.org/10.1007/11693383_22</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/zk-snarks/>Zk-Snarks</a></li><li><a href=http://localhost:1313/tags/python/>Python</a></li><li><a href=http://localhost:1313/tags/mathematics/>Mathematics</a></li><li><a href=http://localhost:1313/tags/groth16/>Groth16</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/post-004/><span class=title>« Prev</span><br><span>ZK003: Elliptic Curve Arithmetic in Python</span>
</a><a class=next href=http://localhost:1313/posts/post-002/><span class=title>Next »</span><br><span>ZK001: Finite Field Arithmetic in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>