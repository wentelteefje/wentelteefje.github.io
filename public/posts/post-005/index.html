<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZK004: Optimal Ate Pairing in Python | a5xz2</title>
<meta name=keywords content="zk-snarks,python,mathematics,groth16"><meta name=description content="In this part of the series we review and start implementing elliptic curve pairings."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/post-005/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e8e1ca2b036c6bcbd582af4b216275873849c35585cc3b2d6e825eca803671c6.css integrity="sha256-6OHKKwNsa8vVgq9LIWJ1hzhJw1WFzDstboJeyoA2ccY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/post-005/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="ZK004: Optimal Ate Pairing in Python"><meta property="og:description" content="In this part of the series we review and start implementing elliptic curve pairings."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/post-005/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-30T20:29:00+02:00"><meta property="article:modified_time" content="2022-08-30T20:29:00+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ZK004: Optimal Ate Pairing in Python"><meta name=twitter:description content="In this part of the series we review and start implementing elliptic curve pairings."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"ZK004: Optimal Ate Pairing in Python","item":"http://localhost:1313/posts/post-005/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZK004: Optimal Ate Pairing in Python","name":"ZK004: Optimal Ate Pairing in Python","description":"In this part of the series we review and start implementing elliptic curve pairings.","keywords":["zk-snarks","python","mathematics","groth16"],"articleBody":"1. Mathematical Review 1.1 The Optimal Ate pairing Let $n$ be the curve order as determined in the last article, and let $\\pi_p$ be the $p$-th power Frobenius endomorphism, i.e. $\\pi_p(x,y) = (x^p, y^p)$. An Optimal Ate pairing is a non-degenerate bilinear pairing on $E$ with the following setup: $$ \\begin{align*} \\mathbb{G}_1 \u0026:= E[n] \\cap \\ker{(\\pi_p - [1])} = E(\\mathbb{F}_p)[n] \\\\ \\mathbb{G}_2 \u0026:= E[n] \\cap \\ker{(\\pi_p - [p])} \\subseteq E(\\mathbb{F}_{p^{12}})[n] \\\\ \\mathbb{G}_3 \u0026:= \\mu_n = \\lbrace \\zeta\\,|\\,\\zeta^n = 1 \\rbrace \\subset \\mathbb{F}_{p^{12}}^{\\times} \\end{align*}$$\nFor any $P \\in \\mathbb{G}_1, Q \\in \\mathbb{G}_2$ let $\\alpha_{\\textrm{opt}} : \\mathbb{G}_2 \\times \\mathbb{G}_1 \\to \\mu_n$ be defined as: $$ \\alpha_{\\textrm{opt}}(Q,P) := \\left( f_{6u+2,Q}(P) \\cdot h_{6u+2,Q}(P) \\right)^{\\frac{p^{12}-1}{n}} $$ where $h_{6u+2,Q}(P) = l_{[6u+2]Q,Q_1}(P) \\cdot l_{[6u+2]Q+Q_1,−Q_2}(P)$. In this definition the value $l_{R,S}(P) \\in \\mathbb{F}_{p^{12}}$ is obtained by evaluating the equation of the line through the points $R$ and $S$ on $E$ at the point $P$. The special points $Q_1, Q_2$ are defined using the Frobenius endomorphism as $Q_1 := \\pi_p(Q)$ and $Q_2 := \\pi_p^2(Q) = \\pi_p(Q_1)$ and $f, h$ are rational functions on $\\mathbb{F}_{p^{12}}$.\nAdditionally, all(really everthing?) curve arithmetic is done on the sextic twist $E’: y^2 = x^3 + b/\\xi$ defined over $\\mathbb{F}_{p^2}$. We represent each point $R \\in \\mathbb{G}_2$ as an image $R = \\psi(R’)$ of a point $R’ \\in E’(\\mathbb{F}_{p^2})$, where $\\psi : E’ \\to E, (x’, y’) \\mapsto (\\omega^2 x’, \\omega^3 y’ )$ is the corresponding twist isomorphism.\n# w = 0x^0 +1x^1 + ... 0x^11 w = FQ12([0, 1] + [0] * 10) 1.2 Computing the Ate - Miller’s Algorithm To actually calculate the pairing we need Miller’s algorithm (more commonly just Miller loop), the basics of which we would like to briefly motivate here. Suppose $f$ is a rational function on $E$, i.e. $f$ can be written as a ratio of polynomials $$f(X) = \\frac{a_0 + a_1X + a_2X^2 + … + a_n X^l}{b_0 + b_1X + b_2X^2 + … + b_mX^m} = \\frac{a(X-\\alpha_1)^{e_1} \\cdot … \\cdot (X-\\alpha_r)^{e_r} }{b(X-\\beta_1)^{d_1} \\cdot … \\cdot (X-\\beta_s)^{d_s} }$$ with zeroes $\\alpha_1, …, \\alpha_r$ and poles $\\beta_1, …, \\beta_s$ with corresponding multiplicities $e_1, …, e_r$ and $d_1, …, d_s$. We define the divisor $(f)$ of a rational function $f$ as a formal sum to keep track of the zeroes and poles associated with $f$: $$ (f) = \\sum_i e_i[\\alpha_i] + \\sum_j -d_j[\\beta_j].$$\nMiller’s algorithm exploits a simple but powerful theorem of elliptic curves. When $f$ and $g$ are two non-zero rational functions on $E$ with $(f) = (g)$, then we already have $f = cg$ for some non-zero constant $c$ (Source: [X], Thm Y.Z). This means, that the actual choice of the rational functions involved in the computations doesn’t matter, rather it’s their divisors which are of main interest.\nFor any $Q \\in E(\\mathbb{F}_{p^{12}})$ and integer $s$, let $f_{s,Q}$ be a $\\mathbb{F}_{p^{12}}$-rational function with divisor:\n$$(f_{s,Q}) = s(Q) - ([s]Q) - (s-1)\\mathcal{O}.$$\nThis function $f_{s,Q}$ is a so-called Miller function, which is determined uniquely up to a non-zero constant $c \\in \\mathbb{F}_{p^{12}}$. Miller’s algorithm builds up these functions $f_{s,Q}$ in a loop according to the following formula: If $l_{[m]Q,[n]Q}$ is the equation of the line through $[m]Q$ and $[n]Q$ (or the tangent when $[m]Q = [n]Q$) and $v_{[m+n]Q}$ is the equation of the vertical line trough $[m + n]Q$, then we have $$ f_{m+n,Q} = f_{m,Q} \\cdot f_{n,Q} \\frac{ l_{[m]Q,[n]Q} } { v_{[m+n]Q} }. $$\nThe interested reader can find a more detailed explanation in [2]. In summary, we compute the Optimal Ate pairing using the Miller loop as $\\alpha_{\\textrm{opt}}(Q,P) = \\operatorname{ML}(P,Q)$. The rest of the article will be dedicated to implementing Miller’s algorithm for BN128. Note: The term optimal in Optimal Ate refers to the fact, that the pairing can be computed in $\\log_2(n)/\\phi(k) + e(k)$ Miller iterations, where $n = |\\mathbb{G}_1| = | \\mathbb{G}_2 | = |\\mathbb{G}_T|$, $\\phi(k)$ is Euler’s totient function evaluated on the embedding degree $k$ and $e(k) \\leq log_2 k$ [3].\n1.1 Miller Loop Following Aranha et al. [1] we are now going to implement a version of Miller’s algorithm to evaluate the Optimal Ate pairing function on $Y^2 = X^3 + 3$. The following is a picture of its pseudocode from the publication.\nWe are going to step by step through the algorithm and simultaneously translate it into Python code. We start with the instantiations on line one.\ndef miller_loop(Q,P): T = Q f = FQ12.one() Recall from the last article, that we obtained the BN128 curve parameters $p(u), n(u)$ with $u = 4965661367192848881$. We can compute the Optimal Ate loop count $r$ and its logarithmic equivalent $t$ as as $$ \\begin{align*} r \u0026= |6u + 2| = \u002629793968203157093288,\\\\ t \u0026= \\lfloor \\log_{2}{r} \\rfloor - 1 = \u002663.\\end{align*}$$ We save $r$ in a Python variable named ate_loop_count and $t$ in a variable named log_ate_loop_count. Additionally, we will make use of the coefficients $r_i$ in the binary representation of $r = \\sum_{i=0}^{\\lfloor \\log_{2}{r} \\rfloor} r_i 2^i$ inside the loop. In particular we want to check in each loop whether $r_i = 1$, i.e. if $r$’s binary representation includes $2^i$ as a summand. We can easily achieve this by using $2^i$ as a bit mask and the bitwise AND operator \u0026.\nfor i in range(log_ate_loop_count, -1, -1): f = f * f * line_func(T,T,P) T = double(T) if ate_loop_count \u0026 (2**i): f = f * line_func(T,Q,P) T = add(T,Q) This concludes the loop. Now we obtain two new points by applying the Frobenius endomorphism to $Q$:\nQ1 = frobenius(Q, p) nQ2 = frobenius(neg(Q1), p) Here we have used the fact that…\nf = f * line_func(T, Q1, P) T = add(T, Q1) f = f * line_func(T, nQ2, P) T = add(T, neg(Q2)) # Final Exponentiation return f ** (( p ** 12 - 1) // curve_order) This concludes the implementation of the Miller loop. Let’s turn to the implementation of the line function subroutine.\n1.2 Line Function For simplicity, we first describe the algorithm in affine coordinates and then we extend it to projective coordinates. Let $P = (x_1, y_1), Q = (x_2, y_2)$ and $T = (x_t, y_t)$ be points, then line_func(P,Q,T) constructs a line through $P$ and $Q$ and evaluates it at $T$. Fortunately, this function is very easy to fathom and we have already supplied all the relevant math in the previous article about Elliptic curves (see section the group law). There are three separate cases we need to take care of.\n(General Line) In the case that $x_1 \\neq x_2$ we have a well-formed line, which can be described by the equation $y = \\lambda_1(x - x_1) + y_1$, where $\\lambda_1 = \\frac{y_2 - y_1}{x_2 - x_1}$ is the slope. We can evaluate it at the point $T$ by computing $ \\lambda_1 \\cdot (x_t - x_1) + (y_1 - y_t).$ (Tangent Line) When $x_1 = x_2$ and $y_1 = y_2$ the line is a tangent to the point $P = Q$ with slope given by $\\lambda_2 = \\frac{3x^2}{2y}$. The evaluation term has the same form as in the first case with $\\lambda_1$ replaced by $\\lambda_2$. (Vertical Line) Lastly, when $x_1 = x_2$ and $y_1 \\neq y_2$ we have the case of a vertical line $X - x_1$, which can be evaluated by computing $x_t - x_1$. As you can see the function is zero whenever $T$ is a point on the line passing through $P$ and $Q$ and non-zero otherwise.\nHow do we need to change this function when working with projective coordinates? We can derive every equation by remembering that two points $P = (X_1, Y_1, Z_1)$ and $Q = (X_2, Y_2, Z_2)$ in projective space are equal, whenever $X_1/Z_1 = X_2/Z_2$ and $Y_1/Z_1 = Y_2/Z_2$. For example, to obtain the slope $\\lambda_1$ of the general line equation: $$\\lambda_1 = \\frac{Y_2/Z_2 - Y_1/Z_1}{X_2/Z_2 - X_1/Z_1} $$ However, to avoid unnecessary divisions we expand the term with $Z_1Z_2$ and save numerator and denominator separately: $$ \\lambda_1 = \\frac{Z_1 Z_2}{Z_1 Z_2} \\lambda_1 = \\frac{Z_1Y_2 - Z_2Y_1}{Z_1X_2 - Z_2X_1} =: \\frac{\\lambda_{1n}}{\\lambda_{1d}}. $$ Using the same procedure (but expanding by $Z^2$) we can obtain an expression for $\\lambda_2$ in projective coordinates as $$\\lambda_2 = \\frac{3X^2}{2ZY} =: \\frac{\\lambda_{2n}}{\\lambda_{2d}}. $$\nWith this we can re-formulate the three cases of the algorithm as follows:\n(General Line) If $\\lambda_{1d} \\neq 0$, then evaluate as $$ \\lambda_1 (X_t/Z_t - X_1/Z_1) + (Y_1/Z_1 - Y_t/Z_t).$$ (Tangent Line) If $\\lambda_{1d} = 0$ and $\\lambda_{1n} = 0$, then evaluate as $$ \\lambda_2 (X_t/Z_t - X_1/Z_1) + (Y_1/Z_1 - Y_t/Z_t).$$ (Vertical Line) Else evaluate as $X_t/Z_t - X_1/Z_1$. Since we can easily modify the Miller loop to operate separately on numerator and denominator we can just return them as a tuple without performing the costly division. For this we need to use another small algebraic transformation. Consider again the case of the general line in the projective setting, then we can write: $$ \\begin{align*}\\lambda_1 \\left(\\frac{X_t}{Z_t} - \\frac{X_1}{Z_1}\\right) + \\left(\\frac{Y_1}{Z_1} - \\frac{Y_t}{Z_t}\\right) \u0026= \\frac{\\lambda_{1n}}{\\lambda_{1d}} \\frac{X_t Z_1 - X_1 Z_t}{Z_1 Z_t} + \\frac{Y_1 Z_t - Y_t Z_1}{Z_1 Z_t} \\\\ \u0026= \\frac{\\lambda_{1n}(X_t Z_1 - X_1 Z_t) + \\lambda_{1d}(Y_1 Z_t - Y_t Z_1)}{\\lambda_{1d} Z_1 Z_t} \\end{align*}$$\ndef line_func(P, Q, T): zero = P[0].__class__.zero() x1, y1, z1 = P x2, y2, z2 = Q xt, yt, zt = T l_n = y2 * z1 - y1 * z2 l_d = x2 * z1 - x1 * z2 if l_d != zero: return l_n * (xt * z1 - x1 * zt) - l_d * (yt * z1 - y1 * zt), l_d * zt * z1 elif l_n == zero: l_n = 3 * x1 * x1 l_d = 2 * y1 * z1 return l_n * (xt * z1 - x1 * zt) - l_d * (yt * z1 - y1 * zt), l_d * zt * z1 else: return xt * z1 - x1 * zt, z1 * zt TODO: replace small x with big X etc.\n1.4 Adapting the Miller Loop Now we have to adapt the implementation of the Miller loop to take into account the separate calculation of numerator and denominator of the line function. Since the output of the line function always occurs only in connection with the variable f, it is sufficient to consider these lines. Thus, we start by splitting f into numerator and denominator:\ndef miller_loop(Q,P): T = Q f_n, f_d = FQ12.one(), FQ12.one() We proceed analogously with the occurrences in the actual loop:\nfor i in range(log_ate_loop_count, -1, -1): lf_n, lf_d = line_func(T,T,P) f_n = f_n * f_n * lf_n f_d = f_d * f_d * lf_d T = double(T) if ate_loop_count \u0026 (2**i): lf_n, lf_d = line_func(T,Q,P) f_n = f_n * lf_n f_d = f_d * lf_d T = add(T,Q) Lastly, we replace the computations after the loop and merge the results before the final exponentiation:\nQ1 = (Q[0] ** field_modulus, Q[1] ** field_modulus, Q[2] ** field_modulus) # assert is_on_curve(Q1, b12) nQ2 = (Q1[0] ** field_modulus, -Q1[1] ** field_modulus, Q1[2] ** field_modulus) # assert is_on_curve(nQ2, b12) _n1, _d1 = linefunc(R, Q1, P) R = add(R, Q1) _n2, _d2 = linefunc(R, nQ2, P) f = f_num * _n1 * _n2 / (f_den * _d1 * _d2) 1.5 Pairing Function Finally, we write a wrapper function that we call to calculate the pairing of two points $P$ and $Q$:\ndef pairing(Q, P): assert is_on_curve(Q, b2) assert is_on_curve(P, b) if P[-1] == P[-1].__class__.zero() or Q[-1] == Q[-1].__class__.zero(): return FQ12.one() return miller_loop(twist(Q), cast_point_to_fq12(P)) References [1] https://www.iacr.org/archive/eurocrypt2011/66320047/66320047.pdf\n[2] https://crypto.stanford.edu/pbc/thesis.pdf\n[3] https://eprint.iacr.org/2008/096.pdf\n","wordCount":"1891","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-08-30T20:29:00+02:00","dateModified":"2022-08-30T20:29:00+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/post-005/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/publications/ title=publications><span>publications</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ZK004: Optimal Ate Pairing in Python
<span class=entry-hint title=Draft><svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2022-08-30 20:29:00 +0200 CEST'>August 30, 2022</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/post-005.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-the-optimal-ate-pairing>1.1 The Optimal Ate pairing</a></li><li><a href=#12-computing-the-ate---millers-algorithm>1.2 Computing the Ate - Miller&rsquo;s Algorithm</a></li><li><a href=#11-miller-loop>1.1 Miller Loop</a></li><li><a href=#12-line-function>1.2 Line Function</a></li><li><a href=#14-adapting-the-miller-loop>1.4 Adapting the Miller Loop</a></li><li><a href=#15-pairing-function>1.5 Pairing Function</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-mathematical-review>1. Mathematical Review<a hidden class=anchor aria-hidden=true href=#1-mathematical-review>#</a></h1><h2 id=11-the-optimal-ate-pairing>1.1 The Optimal Ate pairing<a hidden class=anchor aria-hidden=true href=#11-the-optimal-ate-pairing>#</a></h2><p>Let $n$ be the curve order as determined in the last article, and let $\pi_p$ be the $p$-th power Frobenius endomorphism, i.e. $\pi_p(x,y) = (x^p, y^p)$. An Optimal Ate pairing is a non-degenerate bilinear pairing on $E$ with the following setup:
$$ \begin{align*} \mathbb{G}_1 &:= E[n] \cap \ker{(\pi_p - [1])} = E(\mathbb{F}_p)[n] \\
\mathbb{G}_2 &:= E[n] \cap \ker{(\pi_p - [p])} \subseteq E(\mathbb{F}_{p^{12}})[n] \\
\mathbb{G}_3 &:= \mu_n = \lbrace \zeta\,|\,\zeta^n = 1 \rbrace \subset \mathbb{F}_{p^{12}}^{\times} \end{align*}$$</p><p>For any $P \in \mathbb{G}_1, Q \in \mathbb{G}_2$ let $\alpha_{\textrm{opt}} : \mathbb{G}_2 \times \mathbb{G}_1 \to \mu_n$ be defined as:
$$ \alpha_{\textrm{opt}}(Q,P) := \left( f_{6u+2,Q}(P) \cdot h_{6u+2,Q}(P) \right)^{\frac{p^{12}-1}{n}} $$
where $h_{6u+2,Q}(P) = l_{[6u+2]Q,Q_1}(P) \cdot l_{[6u+2]Q+Q_1,−Q_2}(P)$. In this definition the value $l_{R,S}(P) \in \mathbb{F}_{p^{12}}$ is obtained by evaluating the equation of the line through the points $R$ and $S$ on $E$ at the point $P$. The special points $Q_1, Q_2$ are defined using the Frobenius endomorphism as $Q_1 := \pi_p(Q)$ and $Q_2 := \pi_p^2(Q) = \pi_p(Q_1)$ and $f, h$ are rational functions on $\mathbb{F}_{p^{12}}$.</p><p>Additionally, all(really everthing?) curve arithmetic is done on the sextic twist $E&rsquo;: y^2 = x^3 + b/\xi$ defined over $\mathbb{F}_{p^2}$. We represent each point $R \in \mathbb{G}_2$ as an image $R = \psi(R&rsquo;)$ of a point $R&rsquo; \in E&rsquo;(\mathbb{F}_{p^2})$, where $\psi : E&rsquo; \to E, (x&rsquo;, y&rsquo;) \mapsto (\omega^2 x&rsquo;, \omega^3 y&rsquo; )$ is the corresponding twist isomorphism.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># w = 0x^0 +1x^1 + ... 0x^11</span>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>FQ12</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=12-computing-the-ate---millers-algorithm>1.2 Computing the Ate - Miller&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#12-computing-the-ate---millers-algorithm>#</a></h2><p>To actually calculate the pairing we need Miller&rsquo;s algorithm (more commonly just Miller loop), the basics of which we would like to briefly motivate here. Suppose $f$ is a rational function on $E$, i.e. $f$ can be written as a ratio of polynomials
$$f(X) = \frac{a_0 + a_1X + a_2X^2 + &mldr; + a_n X^l}{b_0 + b_1X + b_2X^2 + &mldr; + b_mX^m} = \frac{a(X-\alpha_1)^{e_1} \cdot &mldr; \cdot (X-\alpha_r)^{e_r} }{b(X-\beta_1)^{d_1} \cdot &mldr; \cdot (X-\beta_s)^{d_s} }$$
with zeroes $\alpha_1, &mldr;, \alpha_r$ and poles $\beta_1, &mldr;, \beta_s$ with corresponding multiplicities $e_1, &mldr;, e_r$ and $d_1, &mldr;, d_s$.
We define the divisor $(f)$ of a rational function $f$ as a formal sum to keep track of the zeroes and poles associated with $f$:
$$ (f) = \sum_i e_i[\alpha_i] + \sum_j -d_j[\beta_j].$$</p><p>Miller&rsquo;s algorithm exploits a simple but powerful theorem of elliptic curves. When $f$ and $g$ are two non-zero rational functions on $E$ with $(f) = (g)$, then we already have $f = cg$ for some non-zero constant $c$ (Source: [X], Thm Y.Z). This means, that the actual choice of the rational functions involved in the computations doesn&rsquo;t matter, rather it&rsquo;s their divisors which are of main interest.</p><p>For any $Q \in E(\mathbb{F}_{p^{12}})$ and integer $s$, let $f_{s,Q}$ be a $\mathbb{F}_{p^{12}}$-rational function with divisor:</p><p>$$(f_{s,Q}) = s(Q) - ([s]Q) - (s-1)\mathcal{O}.$$</p><p>This function $f_{s,Q}$ is a so-called Miller function, which is determined uniquely up to a non-zero constant $c \in \mathbb{F}_{p^{12}}$. Miller’s algorithm builds up these functions $f_{s,Q}$ in a loop according to the following formula: If $l_{[m]Q,[n]Q}$ is the equation of the line through $[m]Q$ and $[n]Q$ (or the tangent when $[m]Q = [n]Q$) and $v_{[m+n]Q}$ is the equation of the vertical line trough $[m + n]Q$, then we have
$$ f_{m+n,Q} = f_{m,Q} \cdot f_{n,Q} \frac{ l_{[m]Q,[n]Q} } { v_{[m+n]Q} }. $$</p><p>The interested reader can find a more detailed explanation in [2]. In summary, we compute the Optimal Ate pairing using the Miller loop as $\alpha_{\textrm{opt}}(Q,P) = \operatorname{ML}(P,Q)$. The rest of the article will be dedicated to implementing Miller&rsquo;s algorithm for <code>BN128</code>.
Note: The term <strong>optimal</strong> in Optimal Ate refers to the fact, that the pairing can be computed in $\log_2(n)/\phi(k) + e(k)$ Miller iterations, where $n = |\mathbb{G}_1| = | \mathbb{G}_2 | = |\mathbb{G}_T|$, $\phi(k)$ is Euler&rsquo;s totient function evaluated on the embedding degree $k$ and $e(k) \leq log_2 k$ [3].</p><h2 id=11-miller-loop>1.1 Miller Loop<a hidden class=anchor aria-hidden=true href=#11-miller-loop>#</a></h2><p>Following Aranha et al. [1] we are now going to implement a version of Miller&rsquo;s algorithm to evaluate the Optimal Ate pairing function on $Y^2 = X^3 + 3$. The following is a picture of its pseudocode from the publication.</p><p><img loading=lazy src=/img/post-005/millerloop.png alt="Miller Loop for Optimal Ate with BN curves"></p><p>We are going to step by step through the algorithm and simultaneously translate it into Python code. We start with the instantiations on line one.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>miller_loop</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>P</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=o>=</span> <span class=n>Q</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span> <span class=o>=</span> <span class=n>FQ12</span><span class=o>.</span><span class=n>one</span><span class=p>()</span>
</span></span></code></pre></div><p>Recall from the last article, that we obtained the <code>BN128</code> curve parameters $p(u), n(u)$ with $u = 4965661367192848881$. We can compute the Optimal Ate loop count $r$ and its logarithmic equivalent $t$ as as
$$ \begin{align*} r &= |6u + 2| = &amp;29793968203157093288,\\
t &= \lfloor \log_{2}{r} \rfloor - 1 = &amp;63.\end{align*}$$
We save $r$ in a Python variable named <code>ate_loop_count</code> and $t$ in a variable named <code>log_ate_loop_count</code>. Additionally, we will make use of the coefficients $r_i$ in the binary representation of $r = \sum_{i=0}^{\lfloor \log_{2}{r} \rfloor} r_i 2^i$ inside the loop. In particular we want to check in each loop whether $r_i = 1$, i.e. if $r$&rsquo;s binary representation includes $2^i$ as a summand. We can easily achieve this by using $2^i$ as a bit mask and the bitwise AND operator <code>&</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>log_ate_loop_count</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span> <span class=o>=</span> <span class=n>f</span> <span class=o>*</span> <span class=n>f</span> <span class=o>*</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>T</span><span class=p>,</span><span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=o>=</span> <span class=n>double</span><span class=p>(</span><span class=n>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>ate_loop_count</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>2</span><span class=o>**</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=n>f</span> <span class=o>*</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>Q</span><span class=p>,</span><span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>Q</span><span class=p>)</span>
</span></span></code></pre></div><p>This concludes the loop. Now we obtain two new points by applying the Frobenius endomorphism to $Q$:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>Q1</span> <span class=o>=</span> <span class=n>frobenius</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>nQ2</span> <span class=o>=</span> <span class=n>frobenius</span><span class=p>(</span><span class=n>neg</span><span class=p>(</span><span class=n>Q1</span><span class=p>),</span> <span class=n>p</span><span class=p>)</span>
</span></span></code></pre></div><p>Here we have used the fact that&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>f</span> <span class=o>*</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>Q1</span><span class=p>,</span> <span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>Q1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>f</span> <span class=o>*</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>nQ2</span><span class=p>,</span> <span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span><span class=p>,</span> <span class=n>neg</span><span class=p>(</span><span class=n>Q2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1># Final Exponentiation</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>f</span> <span class=o>**</span> <span class=p>((</span> <span class=n>p</span> <span class=o>**</span> <span class=mi>12</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=n>curve_order</span><span class=p>)</span>
</span></span></code></pre></div><p>This concludes the implementation of the Miller loop. Let&rsquo;s turn to the implementation of the line function subroutine.</p><h2 id=12-line-function>1.2 Line Function<a hidden class=anchor aria-hidden=true href=#12-line-function>#</a></h2><p>For simplicity, we first describe the algorithm in affine coordinates and then we extend it to projective coordinates. Let $P = (x_1, y_1), Q = (x_2, y_2)$ and $T = (x_t, y_t)$ be points, then <code>line_func(P,Q,T)</code> constructs a line through $P$ and $Q$ and evaluates it at $T$. Fortunately, this function is very easy to fathom and we have already supplied all the relevant math in the previous article about Elliptic curves (see section the group law). There are three separate cases we need to take care of.</p><ol><li>(General Line) In the case that $x_1 \neq x_2$ we have a well-formed line, which can be described by the equation $y = \lambda_1(x - x_1) + y_1$, where $\lambda_1 = \frac{y_2 - y_1}{x_2 - x_1}$ is the slope. We can evaluate it at the point $T$ by computing $ \lambda_1 \cdot (x_t - x_1) + (y_1 - y_t).$</li><li>(Tangent Line) When $x_1 = x_2$ and $y_1 = y_2$ the line is a tangent to the point $P = Q$ with slope given by $\lambda_2 = \frac{3x^2}{2y}$. The evaluation term has the same form as in the first case with $\lambda_1$ replaced by $\lambda_2$.</li><li>(Vertical Line) Lastly, when $x_1 = x_2$ and $y_1 \neq y_2$ we have the case of a vertical line $X - x_1$, which can be evaluated by computing $x_t - x_1$.</li></ol><p>As you can see the function is zero whenever $T$ is a point on the line passing through $P$ and $Q$ and non-zero otherwise.</p><p>How do we need to change this function when working with projective coordinates? We can derive every equation by remembering that two points $P = (X_1, Y_1, Z_1)$ and $Q = (X_2, Y_2, Z_2)$ in projective space are equal, whenever $X_1/Z_1 = X_2/Z_2$ and $Y_1/Z_1 = Y_2/Z_2$. For example, to obtain the slope $\lambda_1$ of the general line equation:
$$\lambda_1 = \frac{Y_2/Z_2 - Y_1/Z_1}{X_2/Z_2 - X_1/Z_1} $$
However, to avoid unnecessary divisions we expand the term with $Z_1Z_2$ and save numerator and denominator separately:
$$ \lambda_1 = \frac{Z_1 Z_2}{Z_1 Z_2} \lambda_1 = \frac{Z_1Y_2 - Z_2Y_1}{Z_1X_2 - Z_2X_1} =: \frac{\lambda_{1n}}{\lambda_{1d}}. $$
Using the same procedure (but expanding by $Z^2$) we can obtain an expression for $\lambda_2$ in projective coordinates as
$$\lambda_2 = \frac{3X^2}{2ZY} =: \frac{\lambda_{2n}}{\lambda_{2d}}. $$</p><p>With this we can re-formulate the three cases of the algorithm as follows:</p><ol><li>(General Line) If $\lambda_{1d} \neq 0$, then evaluate as
$$ \lambda_1 (X_t/Z_t - X_1/Z_1) + (Y_1/Z_1 - Y_t/Z_t).$$</li><li>(Tangent Line) If $\lambda_{1d} = 0$ and $\lambda_{1n} = 0$, then evaluate as
$$ \lambda_2 (X_t/Z_t - X_1/Z_1) + (Y_1/Z_1 - Y_t/Z_t).$$</li><li>(Vertical Line) Else evaluate as $X_t/Z_t - X_1/Z_1$.</li></ol><p>Since we can easily modify the Miller loop to operate separately on numerator and denominator we can just return them as a tuple without performing the costly division. For this we need to use another small algebraic transformation. Consider again the case of the general line in the projective setting, then we can write:
$$ \begin{align*}\lambda_1 \left(\frac{X_t}{Z_t} - \frac{X_1}{Z_1}\right) + \left(\frac{Y_1}{Z_1} - \frac{Y_t}{Z_t}\right) &= \frac{\lambda_{1n}}{\lambda_{1d}} \frac{X_t Z_1 - X_1 Z_t}{Z_1 Z_t} + \frac{Y_1 Z_t - Y_t Z_1}{Z_1 Z_t} \\
&= \frac{\lambda_{1n}(X_t Z_1 - X_1 Z_t) + \lambda_{1d}(Y_1 Z_t - Y_t Z_1)}{\lambda_{1d} Z_1 Z_t} \end{align*}$$</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>line_func</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>Q</span><span class=p>,</span> <span class=n>T</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>zero</span> <span class=o>=</span> <span class=n>P</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=n>zero</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>,</span> <span class=n>z1</span> <span class=o>=</span> <span class=n>P</span>
</span></span><span class=line><span class=cl>    <span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>,</span> <span class=n>z2</span> <span class=o>=</span> <span class=n>Q</span>
</span></span><span class=line><span class=cl>    <span class=n>xt</span><span class=p>,</span> <span class=n>yt</span><span class=p>,</span> <span class=n>zt</span> <span class=o>=</span> <span class=n>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>l_n</span> <span class=o>=</span> <span class=n>y2</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>y1</span> <span class=o>*</span> <span class=n>z2</span>
</span></span><span class=line><span class=cl>    <span class=n>l_d</span> <span class=o>=</span> <span class=n>x2</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>x1</span> <span class=o>*</span> <span class=n>z2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>l_d</span> <span class=o>!=</span> <span class=n>zero</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l_n</span> <span class=o>*</span> <span class=p>(</span><span class=n>xt</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>x1</span> <span class=o>*</span> <span class=n>zt</span><span class=p>)</span> <span class=o>-</span> <span class=n>l_d</span> <span class=o>*</span> <span class=p>(</span><span class=n>yt</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>y1</span> <span class=o>*</span> <span class=n>zt</span><span class=p>),</span> <span class=n>l_d</span> <span class=o>*</span> <span class=n>zt</span> <span class=o>*</span> <span class=n>z1</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>l_n</span> <span class=o>==</span> <span class=n>zero</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>l_n</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>x1</span> <span class=o>*</span> <span class=n>x1</span>
</span></span><span class=line><span class=cl>        <span class=n>l_d</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>y1</span> <span class=o>*</span> <span class=n>z1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l_n</span> <span class=o>*</span> <span class=p>(</span><span class=n>xt</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>x1</span> <span class=o>*</span> <span class=n>zt</span><span class=p>)</span> <span class=o>-</span> <span class=n>l_d</span> <span class=o>*</span> <span class=p>(</span><span class=n>yt</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>y1</span> <span class=o>*</span> <span class=n>zt</span><span class=p>),</span> <span class=n>l_d</span> <span class=o>*</span> <span class=n>zt</span> <span class=o>*</span> <span class=n>z1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>xt</span> <span class=o>*</span> <span class=n>z1</span> <span class=o>-</span> <span class=n>x1</span> <span class=o>*</span> <span class=n>zt</span><span class=p>,</span> <span class=n>z1</span> <span class=o>*</span> <span class=n>zt</span>
</span></span></code></pre></div><p>TODO: replace small x with big X etc.</p><h2 id=14-adapting-the-miller-loop>1.4 Adapting the Miller Loop<a hidden class=anchor aria-hidden=true href=#14-adapting-the-miller-loop>#</a></h2><p>Now we have to adapt the implementation of the Miller loop to take into account the separate calculation of numerator and denominator of the line function. Since the output of the line function always occurs only in connection with the variable <code>f</code>, it is sufficient to consider these lines. Thus, we start by splitting <code>f</code> into numerator and denominator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>miller_loop</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>P</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=o>=</span> <span class=n>Q</span>
</span></span><span class=line><span class=cl>  <span class=n>f_n</span><span class=p>,</span> <span class=n>f_d</span> <span class=o>=</span> <span class=n>FQ12</span><span class=o>.</span><span class=n>one</span><span class=p>(),</span> <span class=n>FQ12</span><span class=o>.</span><span class=n>one</span><span class=p>()</span>
</span></span></code></pre></div><p>We proceed analogously with the occurrences in the actual loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>log_ate_loop_count</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>lf_n</span><span class=p>,</span> <span class=n>lf_d</span> <span class=o>=</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>T</span><span class=p>,</span><span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>f_n</span> <span class=o>=</span> <span class=n>f_n</span> <span class=o>*</span> <span class=n>f_n</span> <span class=o>*</span> <span class=n>lf_n</span>
</span></span><span class=line><span class=cl>  <span class=n>f_d</span> <span class=o>=</span> <span class=n>f_d</span> <span class=o>*</span> <span class=n>f_d</span> <span class=o>*</span> <span class=n>lf_d</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>T</span> <span class=o>=</span> <span class=n>double</span><span class=p>(</span><span class=n>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>ate_loop_count</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>2</span><span class=o>**</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>lf_n</span><span class=p>,</span> <span class=n>lf_d</span> <span class=o>=</span> <span class=n>line_func</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>Q</span><span class=p>,</span><span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>f_n</span> <span class=o>=</span> <span class=n>f_n</span> <span class=o>*</span> <span class=n>lf_n</span>
</span></span><span class=line><span class=cl>    <span class=n>f_d</span> <span class=o>=</span> <span class=n>f_d</span> <span class=o>*</span> <span class=n>lf_d</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>T</span><span class=p>,</span><span class=n>Q</span><span class=p>)</span>
</span></span></code></pre></div><p>Lastly, we replace the computations after the loop and merge the results before the final exponentiation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>  <span class=n>Q1</span> <span class=o>=</span> <span class=p>(</span><span class=n>Q</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>,</span> <span class=n>Q</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>,</span> <span class=n>Q</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1># assert is_on_curve(Q1, b12)</span>
</span></span><span class=line><span class=cl>  <span class=n>nQ2</span> <span class=o>=</span> <span class=p>(</span><span class=n>Q1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>,</span> <span class=o>-</span><span class=n>Q1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>,</span> <span class=n>Q1</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>**</span> <span class=n>field_modulus</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1># assert is_on_curve(nQ2, b12)</span>
</span></span><span class=line><span class=cl>  <span class=n>_n1</span><span class=p>,</span> <span class=n>_d1</span> <span class=o>=</span> <span class=n>linefunc</span><span class=p>(</span><span class=n>R</span><span class=p>,</span> <span class=n>Q1</span><span class=p>,</span> <span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>R</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=n>R</span><span class=p>,</span> <span class=n>Q1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>_n2</span><span class=p>,</span> <span class=n>_d2</span> <span class=o>=</span> <span class=n>linefunc</span><span class=p>(</span><span class=n>R</span><span class=p>,</span> <span class=n>nQ2</span><span class=p>,</span> <span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span> <span class=o>=</span> <span class=n>f_num</span> <span class=o>*</span> <span class=n>_n1</span> <span class=o>*</span> <span class=n>_n2</span> <span class=o>/</span> <span class=p>(</span><span class=n>f_den</span> <span class=o>*</span> <span class=n>_d1</span> <span class=o>*</span> <span class=n>_d2</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=15-pairing-function>1.5 Pairing Function<a hidden class=anchor aria-hidden=true href=#15-pairing-function>#</a></h2><p>Finally, we write a wrapper function that we call to calculate the pairing of two points $P$ and $Q$:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python3 data-lang=python3><span class=line><span class=cl><span class=k>def</span> <span class=nf>pairing</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>P</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>is_on_curve</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>b2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>is_on_curve</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>P</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>P</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=n>zero</span><span class=p>()</span> <span class=ow>or</span> <span class=n>Q</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>Q</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=n>zero</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FQ12</span><span class=o>.</span><span class=n>one</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>miller_loop</span><span class=p>(</span><span class=n>twist</span><span class=p>(</span><span class=n>Q</span><span class=p>),</span> <span class=n>cast_point_to_fq12</span><span class=p>(</span><span class=n>P</span><span class=p>))</span>
</span></span></code></pre></div><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>[1] <a href=https://www.iacr.org/archive/eurocrypt2011/66320047/66320047.pdf>https://www.iacr.org/archive/eurocrypt2011/66320047/66320047.pdf</a></p><p>[2] <a href=https://crypto.stanford.edu/pbc/thesis.pdf>https://crypto.stanford.edu/pbc/thesis.pdf</a></p><p>[3] <a href=https://eprint.iacr.org/2008/096.pdf>https://eprint.iacr.org/2008/096.pdf</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/zk-snarks/>Zk-Snarks</a></li><li><a href=http://localhost:1313/tags/python/>Python</a></li><li><a href=http://localhost:1313/tags/mathematics/>Mathematics</a></li><li><a href=http://localhost:1313/tags/groth16/>Groth16</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/><span class=title>« Prev</span><br><span>Merkle Trees for Whitelists in JS</span>
</a><a class=next href=http://localhost:1313/posts/post-004/><span class=title>Next »</span><br><span>ZK003: Elliptic Curve Arithmetic in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>