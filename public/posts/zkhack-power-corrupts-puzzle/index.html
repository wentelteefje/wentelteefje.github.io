<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ZK Hack - Power Corrupts Puzzle Solution | a5xz2</title>
<meta name=keywords content="zk-hack,cheon attack,ECC,Mathematics,Rust"><meta name=description content="In this article, we implement a Cheon attack in Rust to solve the &ldquo;Power Corrupts&rdquo; puzzle, contributed by Stanford&rsquo;s Applied Cryptography group. The focus is on the mathematical intricacies of the attack."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/zkhack-power-corrupts-puzzle/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/zkhack-power-corrupts-puzzle/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="ZK Hack - Power Corrupts Puzzle Solution"><meta property="og:description" content="In this article, we implement a Cheon attack in Rust to solve the &ldquo;Power Corrupts&rdquo; puzzle, contributed by Stanford&rsquo;s Applied Cryptography group. The focus is on the mathematical intricacies of the attack."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/zkhack-power-corrupts-puzzle/"><meta property="og:image" content="http://localhost:1313/img/zkhack/white-logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-31T14:44:26+02:00"><meta property="article:modified_time" content="2024-05-31T14:44:26+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/img/zkhack/white-logo.png"><meta name=twitter:title content="ZK Hack - Power Corrupts Puzzle Solution"><meta name=twitter:description content="In this article, we implement a Cheon attack in Rust to solve the &ldquo;Power Corrupts&rdquo; puzzle, contributed by Stanford&rsquo;s Applied Cryptography group. The focus is on the mathematical intricacies of the attack."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"ZK Hack - Power Corrupts Puzzle Solution","item":"http://localhost:1313/posts/zkhack-power-corrupts-puzzle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZK Hack - Power Corrupts Puzzle Solution","name":"ZK Hack - Power Corrupts Puzzle Solution","description":"In this article, we implement a Cheon attack in Rust to solve the \u0026ldquo;Power Corrupts\u0026rdquo; puzzle, contributed by Stanford\u0026rsquo;s Applied Cryptography group. The focus is on the mathematical intricacies of the attack.","keywords":["zk-hack","cheon attack","ECC","Mathematics","Rust"],"articleBody":"1 Puzzle Description Bob has invented a new pairing-friendly elliptic curve, which he wanted to use with Groth16. For that purpose, Bob has performed a trusted setup, which resulted in an SRS containting a secret $\\tau$ raised to high powers multiplied by a specific generator in both source groups. The exact parameters of the curve and part of the output of the setup are described in the document linked below.\nAlice wants to recover $\\tau$ and she noticed a few interesting details about the curve and the setup. Specifically, she noticed that the sum $d$ of the highest power $d_1$ of $\\tau$ in $\\mathbb{G}_1$ portion of the SRS, meaning the SRS contains an element of the form $\\tau^{d_1} G_1$ where $G_1$ is a generator of $\\mathbb{G}_1$, and the highest power $d_2$ of $\\tau$ in $\\mathbb{G}_2$ divides $q-1$, where $q$ is the order of the groups.\nAdditionally, she managed to perform a social engineering attack on Bob and extract the following information: if you express $\\tau$ as $\\tau = 2^{k_0 + k_1((q-1/d))} \\mod r$, where $r$ is the order of the scalar field, $k_0$ is 51 bits and its fifteen most significant bits are 10111101110 ($15854$ in decimal). That is $A \u003c k_0 \u003c B$ where $A = 1089478584172543$ and $B = 1089547303649280$.\nAlice then remembered the Cheon attack…\nfrom the Puzzle README.md on GitHub Note: There’s a little quirk in the puzzle’s description. It mentions the first 15 bits of $k_0$ (which is supposed to be a $51$ bit long integer), but the supplied bitstring is only $11$ bits long. Moreover, this bitstring is equal to the decimal $1518$, not $15854$. However, $15854$ is $14$ bits long. It turns out that $k_0$ is actually $50$ bits long and we should use the decimal representaton of $15854$ as the most significant bits of this length $50$ bitstring. In this way we obtain the lower bound mentioned in the text plus one, i.e $A + 1$.\nlet MSBs = format!{\"{:b}\", 15854}; let padded_bits = format!(\"{:0\u003c50}\", MSBs); let Ap1 = u64::from_str_radix(\u0026padded_bits, 2).unwrap(); assert_eq!(1089478584172543, Ap1 - 1); 2 Solution 2.1 Cheon’s Discrete Logarithm Attack Cheon proposed an algorithm for the discrete logarithm problem (DLP) with auxiliary inputs. In general, the DLP for a group $\\mathbb{G}$ is defined as: For a given input $(g, g^\\tau) \\in \\mathbb{G}^2$, compute $\\tau \\in \\mathbb{F}_q$. The auxiliary input in Cheon’s algorithm refers to the knowledge of an additional group element $g^{\\tau^d}$. Suppose $g, g^{\\tau}, g^{\\tau^d} \\in \\mathbb{G}$ are given for a divisor $d$ of $q-1$. Let $$\\tau = \\zeta^{k_0 + k_1 \\frac{q-1}{d}}$$ for $0 \\leq k_0 \u003c \\frac{q-1}{d}$ and $0 \\leq k_1 \u003c d$ for a primitive element $\\zeta$ of $\\mathbb{F}_q^{\\times}$. Then the secret element $\\tau \\in \\mathbb{F}_q$ can be computed deterministically by a succession of two rounds of Baby-step Giant-step in $\\mathcal{O}(\\sqrt{q/d} + \\sqrt{d})$ exponentiations and by using $\\mathcal{O}(\\max{(\\sqrt{q/d}, \\sqrt{d})})$ storage. In the following we will make use of this attack to solve the puzzle.\n2.2 Puzzle Setup We are given the elements:\n$P, \\tau P$ and $\\tau^{d_1} P$ of the group $\\mathbb{G}_1$, and $Q$ and $\\tau^{d_2} Q$ of the group $\\mathbb{G}_2$. Here, $P$ and $Q$ are generators of the respective groups. We only know that $d_1 + d_2$ divides $q - 1$, so the requirements for Cheon’s attack are not fulfilled. However, since the given curve is pairing-friendly we can make use of the bilinear pairing $$e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T$$ to transform the problem to obtain suitable group elements. First, we set $g := e(P, Q).$ With this we obtain $$e(\\tau P, Q) = e(P, Q)^{\\tau} = g^{\\tau}.$$ Now, remember Cheon’s attack requires us to have an element $g^{\\tau^{d}}$, such that $d | (q- 1)$. For this we let $d:= d_1 + d_2$ and use the points $\\tau^{d_1}P$ and $\\tau^{d_2}Q$: $$e(\\tau^{d_1}P, \\tau^{d_2}Q) = e(P, Q)^{\\tau^{d_1+d_2}} = e(P,Q)^{\\tau^d} = g^{\\tau^d}.$$ Having obtained the three group elements $g, g^{\\tau}$ and $g^{\\tau^d}$ we are ready to implement Cheon’s attack. According to Alice, we can write $$\\tau = 2^{k_0 + k_1\\frac{q-1}{d}} \\pmod{q},$$ where $0 \\leq k_0 \u003c \\frac{q-1}{d}$ and $0 \\leq k_1 \u003c d$. This means that $\\zeta := 2$ is a primitive element of $\\mathbb{F}_q^{\\times}$, i.e. $2$ generates $\\mathbb{F}_q^{\\times}$. Any non-zero element $\\alpha \\in \\mathbb{F}_q$ can be written as $2^i$ for some $i \\in \\mathbb{N}$. Since $d$ divides $q-1$, the expression $k_0 + k_1\\frac{q-1}{d}$ yields a natural number. We are now going to compute $k_0$ and $k_1$ to recover $\\tau$. This is done by confining the search space using the two subgroups $H_1$ and $H_2$ to be defined in the next sections.\n2.3 Solving the DLP in $H_1$ The first step of Cheon’s attack is to compute $k_0$ using BSGS. Luckily, we already know the first $14$ bits of $k_0$, so we only need to find the remaining $36$ bits. We use the knowledge of $\\tau$’s representation from Alice to restrict the search space as follows: $$\\tau = 2^{k_0 + k_1 \\frac{q-1}{d}} \\implies \\tau^d = 2^{dk_0 + k_1(q-1)} = 2^{dk_0}(2^{k_1})^{q-1} = (2^{d})^{k_0}.$$ Here we used Fermat’s Little Theorem to obtain $(2^{k_1})^{q-1} = 1 \\pmod{q}$. So, in short this means that finding $k_0$ is equivalent to solving the DLP given by the equation $(2^{d})^{k_0} = \\tau^d$.\nMoreover, this DLP is restricted to the subgroup1 $H_1 := \\{x^d | x \\in \\mathbb{F}_q^{\\times} \\},$ i.e. the elements of $d$-th powers in $\\mathbb{F}_q^{\\times}$. The order $|H_1|$ of this subgroup is $\\frac{q-1}{d}$, which is easy to show2.\nUsing BSGS we can solve this DLP in $H_1$ by making a space-time tradeoff, splitting the remaining $2^{36}$ possibilities in half. To account for the known $14$ bits stored in $A$ we re-write $k_0$ as $$k_0 = A + i\\cdot 2^{18} + j,$$where $0 \\leq i,j \\leq 2^{18}$. Therefore, we have $$\\tau^d = (2^d)^{k_0} = (2^d)^{A + i\\cdot 2^{18} +j} = (2^d)^{A+i\\cdot 2^{18}}(2^d)^{j}.$$ We re-arrange the terms a bit more to obtain the common BSGS formula: $$\\tau^d(2^{-d})^{A+i\\cdot 2^{18}} = (2^d)^{j}.$$ In this expression the right side corresponds to the “baby steps”, whereas the left side are the “giant steps”. There’s just one problem: Unfortunately, we don’t know $\\tau^d$, we only know $g^{\\tau^d}$, that’s why another exponentiation with $g$ is needed: $$g^{\\tau^d}g^{(2^{-d})^{A+i\\cdot 2^{18}}} = (g^{2^d})^{j}.$$\nWith this setup, we can finally use BSGS to determine a value for $k_0$, which turns out to be equal to $1089539821761426$.\n2.4 Solving the DLP in $H_2$ In the final step, we’ll use $k_0$ to determine $k_1$. This time we operate in the subgroup $H_2 := \\{x^{\\frac{q-1}{d}} | x \\in \\mathbb{F}_q^{\\times} \\}$ generated by the element $2^{\\frac{q-1}{d}}$. This group is of order $d$ and $d$ has $30$ bits, so we start with the following split of $k_1$: $$k_1 = i\\cdot 2^{15} + j,$$ with $0 \\leq i,j \\leq 2^{15}$. Keeping this in mind we go on to formulate the DLP in $H_2$: $$\\tau = 2^{k_0 + k_1\\frac{q-1}{d}} = 2^{k_0} \\cdot (2^{\\frac{q-1}{d}})^{k_1}.$$ We once again re-arrange this into the typical BSGS formula and exponentiate with $g$ to obtain: $$(g^{\\tau})^{2^{-k_0}} (g^{-{2^{\\frac{q-1}{d}}}})^{i\\cdot 2^{15}} = (g^{2^{\\frac{q-1}{d}}})^{j}$$ Again, the right side corresponds to the “baby steps” and the left side corresponds to the “giant steps”. Using these parameters for BSGS we obtain $k_1 = 690599720$.\n2.5 Baby-Step Giant-Step Implementation In the BSGS implementation we utilize the functions supplied in the utils.rs file, as well as the relevant traits from the ark-ff crate. To calculate the “baby steps” we can conveniently use the supplied pow_sp2 function, which returns a HashMap object with values $p^{\\text{exp}}, p^{\\text{exp}^{2}}, …., p^{\\text{exp}^{n}}$. Additionally, we are introducing a split parameter to adjust the number of “baby steps”, and accordingly the “length” of the “giant steps”. For example, for the calculation of $k_0$ above we decided on letting split = 1 \u003c\u003c 18 ($2^{18}$), but depending on the machine other values may improve performance.\nfn baby_step_giant_step\u003cS: Field\u003e(a: S, b: Fr, group_ord: u64, mut giant: S, split: u64) -\u003e Option\u003cu64\u003e { let baby_steps = pow_sp2(a, b, split); let giant_step = pow_sp(b.inverse().unwrap(), split.into(), 64).into_bigint(); let n = group_ord / split; for i in 0..n { if let Some(j) = baby_steps.get(\u0026giant) { // return Some(i * split + (*j)); return Some(i * split + (*j)); } giant = giant.pow(giant_step); } None } In summary, the first round of BSGS is run with baby_steps $= (g^{2^{d}})^j$, giant $= (g^{\\tau^d})^{(2^{-d})^A}$ and giant_step $= (2^{-d})^{2^{18}}$.\nlet A: u64 = 1089478584172544; let two_pow_d = pow_sp(Fr::from(2u64), d.into(), 31); let giant = g_tau_d.pow(pow_sp(two_pow_d.inverse().unwrap(), A.into(), 51).into_bigint()); // Solve DLP in H_1, i.e. find k0 let k0 = match baby_step_giant_step(g, two_pow_d, q1_d, giant, 1 \u003c\u003c 20) { Some(result) =\u003e A + result, None =\u003e { eprintln!(\"Error: BSGS failed to find k0.\"); std::process::exit(1); } }; The second round of BSGS is run with baby_steps $= (g^{2^{\\frac{q-1}{d}}})^j$, giant $= (g^\\tau)^{2^{-{k_0}}}$ and giant_step $= (2^{-\\frac{q-1}{d}})^{2^{18}}$.\nlet two_pow_q1_d = pow_sp(Fr::from(2u64), q1_d.into(), 51); let giant = g_tau.pow(pow_sp(Fr::from(2u64).inverse().unwrap(), k0.into(), 51).into_bigint()); // Solve DLP in H_2, i.e. find k1 let k1 = match baby_step_giant_step(g, two_pow_q1_d, d, giant, 1 \u003c\u003c 16) { Some(k1) =\u003e k1, None =\u003e { eprintln!(\"Error: BSGS failed to find k1.\"); std::process::exit(1); } }; 2.6 Recovering $\\tau$ With the computed values for $k_0$ and $k_1$ we can now finally compute $\\tau$: $$ \\tau = 2^{k_0 + k_1 \\frac{q-1}{d}} = 284865198031253921498207.$$\n// Calculate τ = 2^(k0 + k1 (q-1)/d) let exp = (k0 as u128) + (k1 as u128) * (q1_d as u128); let tau = pow_sp(Fr::from(2u64), exp, 80); 3 Complete Rust Implementation use ark_bls12_cheon::{Bls12Cheon, Fq12, Fr, G1Projective as G1, G2Projective as G2}; use crate::utils::{bigInt_to_u128, pow_sp, pow_sp2}; use ark_ec::pairing::Pairing; use ark_ff::{Field, PrimeField}; const d1: u64 = 11726539; const d2: u64 = 690320833; const d: u64 = d1 + d2; const q: u128 = 1114157594638178892192613; const q1_d: u64 = ((q - 1) / d as u128 ) as u64; pub fn attack(P: G1, tau_P: G1, tau_d1_P: G1, Q: G2, tau_d2_Q: G2) -\u003e i128 { // Using pairing to obtain g := e(P,Q), g^tau := e(tau P,Q), g^tau^d = e(tau^d P, Q) let g: Fq12 = Bls12Cheon::pairing(P, Q).0; let g_tau: Fq12 = Bls12Cheon::pairing(tau_P, Q).0; let g_tau_d: Fq12 = Bls12Cheon::pairing(tau_d1_P, tau_d2_Q).0; let A: u64 = 1089478584172544; let two_pow_d = pow_sp(Fr::from(2u64), d.into(), 31); let giant = g_tau_d.pow(pow_sp(two_pow_d.inverse().unwrap(), A.into(), 51).into_bigint()); // Solve DLP in H_1, i.e. find k0 let k0 = match baby_step_giant_step(g, two_pow_d, q1_d, giant, 1 \u003c\u003c 20) { Some(result) =\u003e A + result, None =\u003e { eprintln!(\"Error: BSGS failed to find k0.\"); std::process::exit(1); } }; println!(\"Found k0 = {}\", k0); let two_pow_q1_d = pow_sp(Fr::from(2u64), q1_d.into(), 51); let giant = g_tau.pow(pow_sp(Fr::from(2u64).inverse().unwrap(), k0.into(), 51).into_bigint()); // Solve DLP in H_2, i.e. find k1 let k1 = match baby_step_giant_step(g, two_pow_q1_d, d, giant, 1 \u003c\u003c 16) { Some(k1) =\u003e k1, None =\u003e { eprintln!(\"Error: BSGS failed to find k1.\"); std::process::exit(1); } }; println!(\"Found k1 = {}\", k1); // Calculate τ = 2^(k0 + k1 (q-1)/d) let exp = (k0 as u128) + (k1 as u128) * (q1_d as u128); let tau = pow_sp(Fr::from(2u64), exp, 80); println!(\"Found τ = {}\", tau); return bigInt_to_u128(tau.into_bigint()) as i128; } fn baby_step_giant_step\u003cS: Field\u003e(a: S, b: Fr, group_ord: u64, mut giant: S, split: u64) -\u003e Option\u003cu64\u003e { let baby_steps = pow_sp2(a, b, split); let giant_step = pow_sp(b.inverse().unwrap(), split.into(), 64).into_bigint(); let n = group_ord / split; for i in 0..n { if let Some(j) = baby_steps.get(\u0026giant) { // return Some(i * split + (*j)); return Some(i * split + (*j)); } giant = giant.pow(giant_step); } None } 4 References [1] “Cheon’s discrete log attack, and its relevance to zk-SNARKs” - https://hackmd.io/2oUhPtzWSRulLQ83Ctoy_g\nThis is because evidently $\\tau^d \\in H_1$, so $H_1$ is non-empty and for elements $g := x^d, h := y^d \\in H_1$ we have $$gh^{-1} = x^d(y^d)^{-1} = x^d(y^{-1})^d = (xy^{-1})^d.$$It follows that $x^d(y^d)^{-1} \\in H_1$ and from the One-Step Subgroup Test we conclude, that $H_1$ is indeed a subgroup of $\\mathbb{F}_q^{\\times}$. ↩︎\nThis is true, since $\\mathbb{F}_q^{\\times}$ is a cyclic group of order $q-1$. Let $g$ be a generator of this group, then to obtain the order of $H_1$ it is enough to calculate the order of $g^d$. In other words, we need to find the smallest $n \\in \\mathbb{N}$, such that $$(g^{d})^n = g^{dn} = 1$$Since $g$ is a generator, the equation implies that $dn$ must be a multiple of the order of the group, which is $q−1$. In other words: $$dn = m(q-1)$$The smallest positive $n$ that satisfies this equation occurs when $n = \\frac{q-1}{d}$. This is because $d$ divides $q-1$. ↩︎\n","wordCount":"2029","inLanguage":"en","image":"http://localhost:1313/img/zkhack/white-logo.png","datePublished":"2024-05-31T14:44:26+02:00","dateModified":"2024-05-31T14:44:26+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/zkhack-power-corrupts-puzzle/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ZK Hack - Power Corrupts Puzzle Solution</h1><div class=post-meta><span title='2024-05-31 14:44:26 +0200 CEST'>May 31, 2024</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/zkhack-power-corrupts-puzzle.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/img/zkhack/white-logo.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-puzzle-description>1 Puzzle Description</a></li><li><a href=#2-solution>2 Solution</a><ul><li><a href=#21-cheons-discrete-logarithm-attack>2.1 Cheon&rsquo;s Discrete Logarithm Attack</a></li><li><a href=#22-puzzle-setup>2.2 Puzzle Setup</a></li><li><a href=#23-solving-the-dlp-in-h_1>2.3 Solving the DLP in $H_1$</a></li><li><a href=#24-solving-the-dlp-in-h_2>2.4 Solving the DLP in $H_2$</a></li><li><a href=#25-baby-step-giant-step-implementation>2.5 Baby-Step Giant-Step Implementation</a></li><li><a href=#26-recovering-tau>2.6 Recovering $\tau$</a></li></ul></li><li><a href=#3-complete-rust-implementation>3 Complete Rust Implementation</a></li><li><a href=#4-references>4 References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1-puzzle-description>1 Puzzle Description<a hidden class=anchor aria-hidden=true href=#1-puzzle-description>#</a></h2><blockquote><p>Bob has invented a new pairing-friendly elliptic curve, which he wanted to use with Groth16.
For that purpose, Bob has performed a trusted setup, which resulted in an SRS containting
a secret $\tau$ raised to high powers multiplied by a specific generator in both source groups.
The exact parameters of the curve and part of the output of the setup are described in the
document linked below.</p><p>Alice wants to recover $\tau$ and she noticed a few interesting details about the curve and
the setup. Specifically, she noticed that the sum $d$ of the highest power $d_1$ of $\tau$ in
$\mathbb{G}_1$ portion of the SRS, meaning the SRS contains an element of the form
$\tau^{d_1} G_1$ where $G_1$ is a generator of $\mathbb{G}_1$, and the highest power $d_2$
of $\tau$ in $\mathbb{G}_2$ divides $q-1$, where $q$ is the order of the groups.</p><p>Additionally, she managed to perform a social engineering attack on Bob and extract the
following information: if you express $\tau$ as $\tau = 2^{k_0 + k_1((q-1/d))} \mod r$,
where $r$ is the order of the scalar field, $k_0$ is 51 bits and its fifteen most
significant bits are 10111101110 ($15854$ in decimal). That is $A &lt; k_0 &lt; B$ where
$A = 1089478584172543$ and $B = 1089547303649280$.</p><p>Alice then remembered the Cheon attack&mldr;</p></blockquote><ul><li>from the Puzzle README.md on <a href=https://github.com/ZK-Hack/puzzle-power-corrupts>GitHub</a></li></ul><p>Note: There&rsquo;s a little quirk in the puzzle&rsquo;s description. It mentions the first 15 bits of $k_0$ (which is supposed to be a $51$ bit long integer), but the supplied bitstring is only $11$ bits long. Moreover, this bitstring is equal to the decimal $1518$, not $15854$. However, $15854$ is $14$ bits long. It turns out that $k_0$ is actually $50$ bits long and we should use the decimal representaton of $15854$ as the most significant bits of this length $50$ bitstring. In this way we obtain the lower bound mentioned in the text plus one, i.e $A + 1$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>MSBs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>{</span><span class=s>&#34;{:b}&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>15854</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>padded_bits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:0&lt;50}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>MSBs</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>Ap1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>u64</span>::<span class=n>from_str_radix</span><span class=p>(</span><span class=o>&amp;</span><span class=n>padded_bits</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>1089478584172543</span><span class=p>,</span><span class=w> </span><span class=n>Ap1</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h2 id=2-solution>2 Solution<a hidden class=anchor aria-hidden=true href=#2-solution>#</a></h2><h3 id=21-cheons-discrete-logarithm-attack>2.1 Cheon&rsquo;s Discrete Logarithm Attack<a hidden class=anchor aria-hidden=true href=#21-cheons-discrete-logarithm-attack>#</a></h3><p><a href=http://www.math.snu.ac.kr/~jhcheon/publications/2010/StrongDH_JoC_Final2.pdf>Cheon</a> proposed an algorithm for the discrete logarithm problem (DLP) with auxiliary inputs. In general, the DLP for a group $\mathbb{G}$ is defined as: For a given input $(g, g^\tau) \in \mathbb{G}^2$, compute $\tau \in \mathbb{F}_q$. The auxiliary input in Cheon&rsquo;s algorithm refers to the knowledge of an additional group element $g^{\tau^d}$. Suppose $g, g^{\tau}, g^{\tau^d} \in \mathbb{G}$ are given for a divisor $d$ of $q-1$. Let $$\tau = \zeta^{k_0 + k_1 \frac{q-1}{d}}$$ for $0 \leq k_0 &lt; \frac{q-1}{d}$ and $0 \leq k_1 &lt; d$ for a primitive element $\zeta$ of $\mathbb{F}_q^{\times}$. Then the secret element $\tau \in \mathbb{F}_q$ can be computed deterministically by a succession of two rounds of Baby-step Giant-step in $\mathcal{O}(\sqrt{q/d} + \sqrt{d})$ exponentiations and by using $\mathcal{O}(\max{(\sqrt{q/d}, \sqrt{d})})$ storage. In the following we will make use of this attack to solve the puzzle.</p><h3 id=22-puzzle-setup>2.2 Puzzle Setup<a hidden class=anchor aria-hidden=true href=#22-puzzle-setup>#</a></h3><p>We are <a href=https://gist.github.com/kobigurk/352036cee6cb8e44ddf0e231ee9c3f9b>given</a> the elements:</p><ul><li>$P, \tau P$ and $\tau^{d_1} P$ of the group $\mathbb{G}_1$, and</li><li>$Q$ and $\tau^{d_2} Q$ of the group $\mathbb{G}_2$.</li></ul><p>Here, $P$ and $Q$ are generators of the respective groups. We only know that $d_1 + d_2$ divides $q - 1$, so the requirements for Cheon&rsquo;s attack are not fulfilled. However, since the given curve is pairing-friendly we can make use of the bilinear pairing $$e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$$ to transform the problem to obtain suitable group elements. First, we set $g := e(P, Q).$
With this we obtain $$e(\tau P, Q) = e(P, Q)^{\tau} = g^{\tau}.$$
Now, remember Cheon&rsquo;s attack requires us to have an element $g^{\tau^{d}}$, such that $d | (q- 1)$. For this we let $d:= d_1 + d_2$ and use the points $\tau^{d_1}P$ and $\tau^{d_2}Q$: $$e(\tau^{d_1}P, \tau^{d_2}Q) = e(P, Q)^{\tau^{d_1+d_2}} = e(P,Q)^{\tau^d} = g^{\tau^d}.$$
Having obtained the three group elements $g, g^{\tau}$ and $g^{\tau^d}$ we are ready to implement Cheon&rsquo;s attack.
According to Alice, we can write $$\tau = 2^{k_0 + k_1\frac{q-1}{d}} \pmod{q},$$
where $0 \leq k_0 &lt; \frac{q-1}{d}$ and $0 \leq k_1 &lt; d$. This means that $\zeta := 2$ is a primitive element of $\mathbb{F}_q^{\times}$, i.e. $2$ generates $\mathbb{F}_q^{\times}$. Any non-zero element $\alpha \in \mathbb{F}_q$ can be written as $2^i$ for some $i \in \mathbb{N}$. Since $d$ divides $q-1$, the expression $k_0 + k_1\frac{q-1}{d}$ yields a natural number. We are now going to compute $k_0$ and $k_1$ to recover $\tau$. This is done by confining the search space using the two subgroups $H_1$ and $H_2$ to be defined in the next sections.</p><h3 id=23-solving-the-dlp-in-h_1>2.3 Solving the DLP in $H_1$<a hidden class=anchor aria-hidden=true href=#23-solving-the-dlp-in-h_1>#</a></h3><p>The first step of Cheon&rsquo;s attack is to compute $k_0$ using BSGS. Luckily, we already know the first $14$ bits of $k_0$, so we only need to find the remaining $36$ bits. We use the knowledge of $\tau$&rsquo;s representation from Alice to restrict the search space as follows:
$$\tau = 2^{k_0 + k_1 \frac{q-1}{d}} \implies \tau^d = 2^{dk_0 + k_1(q-1)} = 2^{dk_0}(2^{k_1})^{q-1} = (2^{d})^{k_0}.$$
Here we used Fermat&rsquo;s Little Theorem to obtain $(2^{k_1})^{q-1} = 1 \pmod{q}$. So, in short this means that finding $k_0$ is equivalent to solving the DLP given by the equation $(2^{d})^{k_0} = \tau^d$.</p><p>Moreover, this DLP is restricted to the subgroup<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> $H_1 := \{x^d | x \in \mathbb{F}_q^{\times} \},$ i.e. the elements of $d$-th powers in $\mathbb{F}_q^{\times}$. The order $|H_1|$ of this subgroup is $\frac{q-1}{d}$, which is easy to show<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Using BSGS we can solve this DLP in $H_1$ by making a space-time tradeoff, splitting the remaining $2^{36}$ possibilities in half. To account for the known $14$ bits stored in $A$ we re-write $k_0$ as $$k_0 = A + i\cdot 2^{18} + j,$$where $0 \leq i,j \leq 2^{18}$. Therefore, we have $$\tau^d = (2^d)^{k_0} = (2^d)^{A + i\cdot 2^{18} +j} = (2^d)^{A+i\cdot 2^{18}}(2^d)^{j}.$$
We re-arrange the terms a bit more to obtain the common BSGS formula: $$\tau^d(2^{-d})^{A+i\cdot 2^{18}} = (2^d)^{j}.$$
In this expression the right side corresponds to the &ldquo;baby steps&rdquo;, whereas the left side are the &ldquo;giant steps&rdquo;. There&rsquo;s just one problem: Unfortunately, we don&rsquo;t know $\tau^d$, we only know $g^{\tau^d}$, that&rsquo;s why another exponentiation with $g$ is needed:
$$g^{\tau^d}g^{(2^{-d})^{A+i\cdot 2^{18}}} = (g^{2^d})^{j}.$$</p><p>With this setup, we can finally use BSGS to determine a value for $k_0$, which turns out to be equal to $1089539821761426$.</p><h3 id=24-solving-the-dlp-in-h_2>2.4 Solving the DLP in $H_2$<a hidden class=anchor aria-hidden=true href=#24-solving-the-dlp-in-h_2>#</a></h3><p>In the final step, we&rsquo;ll use $k_0$ to determine $k_1$. This time we operate in the subgroup $H_2 := \{x^{\frac{q-1}{d}} | x \in \mathbb{F}_q^{\times} \}$ generated by the element $2^{\frac{q-1}{d}}$. This group is of order $d$ and $d$ has $30$ bits, so we start with the following split of $k_1$:
$$k_1 = i\cdot 2^{15} + j,$$
with $0 \leq i,j \leq 2^{15}$. Keeping this in mind we go on to formulate the DLP in $H_2$:
$$\tau = 2^{k_0 + k_1\frac{q-1}{d}} = 2^{k_0} \cdot (2^{\frac{q-1}{d}})^{k_1}.$$
We once again re-arrange this into the typical BSGS formula and exponentiate with $g$ to obtain:
$$(g^{\tau})^{2^{-k_0}} (g^{-{2^{\frac{q-1}{d}}}})^{i\cdot 2^{15}} = (g^{2^{\frac{q-1}{d}}})^{j}$$
Again, the right side corresponds to the “baby steps” and the left side corresponds to the “giant steps”. Using these parameters for BSGS we obtain $k_1 = 690599720$.</p><h3 id=25-baby-step-giant-step-implementation>2.5 Baby-Step Giant-Step Implementation<a hidden class=anchor aria-hidden=true href=#25-baby-step-giant-step-implementation>#</a></h3><p>In the BSGS implementation we utilize the functions supplied in the <code>utils.rs</code> file, as well as the relevant traits from the <code>ark-ff</code> crate. To calculate the &ldquo;baby steps&rdquo; we can conveniently use the supplied <code>pow_sp2</code> function, which returns a <code>HashMap&lt;S, u64></code> object with values $p^{\text{exp}}, p^{\text{exp}^{2}}, &mldr;., p^{\text{exp}^{n}}$. Additionally, we are introducing a <code>split</code> parameter to adjust the number of &ldquo;baby steps&rdquo;, and accordingly the &ldquo;length&rdquo; of the &ldquo;giant steps&rdquo;. For example, for the calculation of $k_0$ above we decided on letting <code>split = 1 &lt;&lt; 18</code> ($2^{18}$), but depending on the machine other values may improve performance.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>baby_step_giant_step</span><span class=o>&lt;</span><span class=n>S</span>: <span class=nc>Field</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=nc>S</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=nc>Fr</span><span class=p>,</span><span class=w> </span><span class=n>group_ord</span>: <span class=kt>u64</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>giant</span>: <span class=nc>S</span><span class=p>,</span><span class=w> </span><span class=n>split</span>: <span class=kt>u64</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>baby_steps</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp2</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>split</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>giant_step</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>split</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>64</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>group_ord</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>split</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>baby_steps</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>giant</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// return Some(i * split + (*j));
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>split</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>j</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>giant</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>giant_step</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In summary, the first round of BSGS is run with <code>baby_steps</code> $= (g^{2^{d}})^j$, <code>giant</code> $= (g^{\tau^d})^{(2^{-d})^A}$ and <code>giant_step</code> $= (2^{-d})^{2^{18}}$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>A</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mi>1089478584172544</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>two_pow_d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>31</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g_tau_d</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>pow_sp</span><span class=p>(</span><span class=n>two_pow_d</span><span class=p>.</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Solve DLP in H_1, i.e. find k0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>k0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>baby_step_giant_step</span><span class=p>(</span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=n>two_pow_d</span><span class=p>,</span><span class=w> </span><span class=n>q1_d</span><span class=p>,</span><span class=w> </span><span class=n>giant</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>result</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;Error: BSGS failed to find k0.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>std</span>::<span class=n>process</span>::<span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></div><p>The second round of BSGS is run with <code>baby_steps</code> $= (g^{2^{\frac{q-1}{d}}})^j$, <code>giant</code> $= (g^\tau)^{2^{-{k_0}}}$ and <code>giant_step</code> $= (2^{-\frac{q-1}{d}})^{2^{18}}$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>two_pow_q1_d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>q1_d</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g_tau</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>).</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>k0</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Solve DLP in H_2, i.e. find k1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>k1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>baby_step_giant_step</span><span class=p>(</span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=n>two_pow_q1_d</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>giant</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>16</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>k1</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>k1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;Error: BSGS failed to find k1.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>std</span>::<span class=n>process</span>::<span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></div><h3 id=26-recovering-tau>2.6 Recovering $\tau$<a hidden class=anchor aria-hidden=true href=#26-recovering-tau>#</a></h3><p>With the computed values for $k_0$ and $k_1$ we can now finally compute $\tau$:
$$ \tau = 2^{k_0 + k_1 \frac{q-1}{d}} = 284865198031253921498207.$$</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Calculate τ = 2^(k0 + k1 (q-1)/d)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>exp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>k0</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>k1</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>q1_d</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>tau</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>exp</span><span class=p>,</span><span class=w> </span><span class=mi>80</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h2 id=3-complete-rust-implementation>3 Complete Rust Implementation<a hidden class=anchor aria-hidden=true href=#3-complete-rust-implementation>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>ark_bls12_cheon</span>::<span class=p>{</span><span class=n>Bls12Cheon</span><span class=p>,</span><span class=w> </span><span class=n>Fq12</span><span class=p>,</span><span class=w> </span><span class=n>Fr</span><span class=p>,</span><span class=w> </span><span class=n>G1Projective</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>G1</span><span class=p>,</span><span class=w> </span><span class=n>G2Projective</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>G2</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>utils</span>::<span class=p>{</span><span class=n>bigInt_to_u128</span><span class=p>,</span><span class=w> </span><span class=n>pow_sp</span><span class=p>,</span><span class=w> </span><span class=n>pow_sp2</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>ark_ec</span>::<span class=n>pairing</span>::<span class=n>Pairing</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>ark_ff</span>::<span class=p>{</span><span class=n>Field</span><span class=p>,</span><span class=w> </span><span class=n>PrimeField</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>d1</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mi>11726539</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>d2</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mi>690320833</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>d</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>d2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>q</span>: <span class=kt>u128</span> <span class=o>=</span><span class=w> </span><span class=mi>1114157594638178892192613</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=n>q1_d</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=p>((</span><span class=n>q</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>attack</span><span class=p>(</span><span class=n>P</span>: <span class=nc>G1</span><span class=p>,</span><span class=w> </span><span class=n>tau_P</span>: <span class=nc>G1</span><span class=p>,</span><span class=w> </span><span class=n>tau_d1_P</span>: <span class=nc>G1</span><span class=p>,</span><span class=w> </span><span class=n>Q</span>: <span class=nc>G2</span><span class=p>,</span><span class=w> </span><span class=n>tau_d2_Q</span>: <span class=nc>G2</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i128</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Using pairing to obtain g := e(P,Q), g^tau := e(tau P,Q), g^tau^d = e(tau^d P, Q)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>g</span>: <span class=nc>Fq12</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Bls12Cheon</span>::<span class=n>pairing</span><span class=p>(</span><span class=n>P</span><span class=p>,</span><span class=w> </span><span class=n>Q</span><span class=p>).</span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>g_tau</span>: <span class=nc>Fq12</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Bls12Cheon</span>::<span class=n>pairing</span><span class=p>(</span><span class=n>tau_P</span><span class=p>,</span><span class=w> </span><span class=n>Q</span><span class=p>).</span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>g_tau_d</span>: <span class=nc>Fq12</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Bls12Cheon</span>::<span class=n>pairing</span><span class=p>(</span><span class=n>tau_d1_P</span><span class=p>,</span><span class=w> </span><span class=n>tau_d2_Q</span><span class=p>).</span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>A</span>: <span class=kt>u64</span> <span class=o>=</span><span class=w> </span><span class=mi>1089478584172544</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>two_pow_d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>31</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g_tau_d</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>pow_sp</span><span class=p>(</span><span class=n>two_pow_d</span><span class=p>.</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Solve DLP in H_1, i.e. find k0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>k0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>baby_step_giant_step</span><span class=p>(</span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=n>two_pow_d</span><span class=p>,</span><span class=w> </span><span class=n>q1_d</span><span class=p>,</span><span class=w> </span><span class=n>giant</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>result</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;Error: BSGS failed to find k0.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>std</span>::<span class=n>process</span>::<span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Found k0 = </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>k0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>two_pow_q1_d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>q1_d</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g_tau</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>).</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>k0</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>51</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Solve DLP in H_2, i.e. find k1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>k1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>baby_step_giant_step</span><span class=p>(</span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=n>two_pow_q1_d</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>giant</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>16</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>k1</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>k1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;Error: BSGS failed to find k1.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>std</span>::<span class=n>process</span>::<span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Found k1 = </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>k1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Calculate τ = 2^(k0 + k1 (q-1)/d)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>exp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>k0</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>k1</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>q1_d</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u128</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tau</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>Fr</span>::<span class=n>from</span><span class=p>(</span><span class=mi>2</span><span class=k>u64</span><span class=p>),</span><span class=w> </span><span class=n>exp</span><span class=p>,</span><span class=w> </span><span class=mi>80</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Found τ = </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>tau</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>bigInt_to_u128</span><span class=p>(</span><span class=n>tau</span><span class=p>.</span><span class=n>into_bigint</span><span class=p>())</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i128</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>baby_step_giant_step</span><span class=o>&lt;</span><span class=n>S</span>: <span class=nc>Field</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=nc>S</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=nc>Fr</span><span class=p>,</span><span class=w> </span><span class=n>group_ord</span>: <span class=kt>u64</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>giant</span>: <span class=nc>S</span><span class=p>,</span><span class=w> </span><span class=n>split</span>: <span class=kt>u64</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>baby_steps</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp2</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>split</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>giant_step</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pow_sp</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>inverse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>split</span><span class=p>.</span><span class=n>into</span><span class=p>(),</span><span class=w> </span><span class=mi>64</span><span class=p>).</span><span class=n>into_bigint</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>group_ord</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>split</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>baby_steps</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>giant</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// return Some(i * split + (*j));
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>split</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>j</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>giant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>giant</span><span class=p>.</span><span class=n>pow</span><span class=p>(</span><span class=n>giant_step</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=4-references>4 References<a hidden class=anchor aria-hidden=true href=#4-references>#</a></h2><p>[1] &ldquo;Cheon&rsquo;s discrete log attack, and its relevance to zk-SNARKs&rdquo; - <a href=https://hackmd.io/2oUhPtzWSRulLQ83Ctoy_g>https://hackmd.io/2oUhPtzWSRulLQ83Ctoy_g</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is because evidently $\tau^d \in H_1$, so $H_1$ is non-empty and for elements $g := x^d, h := y^d \in H_1$ we have $$gh^{-1} = x^d(y^d)^{-1} = x^d(y^{-1})^d = (xy^{-1})^d.$$It follows that $x^d(y^d)^{-1} \in H_1$ and from the One-Step Subgroup Test we conclude, that $H_1$ is indeed a subgroup of $\mathbb{F}_q^{\times}$.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>This is true, since $\mathbb{F}_q^{\times}$ is a cyclic group of order $q-1$. Let $g$ be a generator of this group, then to obtain the order of $H_1$ it is enough to calculate the order of $g^d$. In other words, we need to find the smallest $n \in \mathbb{N}$, such that $$(g^{d})^n = g^{dn} = 1$$Since $g$ is a generator, the equation implies that $dn$ must be a multiple of the order of the group, which is $q−1$. In other words: $$dn = m(q-1)$$The smallest positive $n$ that satisfies this equation occurs when $n = \frac{q-1}{d}$. This is because $d$ divides $q-1$.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/zk-hack/>Zk-Hack</a></li><li><a href=http://localhost:1313/tags/cheon-attack/>Cheon Attack</a></li><li><a href=http://localhost:1313/tags/ecc/>ECC</a></li><li><a href=http://localhost:1313/tags/mathematics/>Mathematics</a></li><li><a href=http://localhost:1313/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/gear/><span class=title>Next »</span><br><span>Block Authoring in Vara Network</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>