<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Merkle Trees for Whitelists in JS | a5xz2</title>
<meta name=keywords content="JS,merkle tree,merkle proof"><meta name=description content="In this article, we&rsquo;ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples."><meta name=author content="wentelteefje"><link rel=canonical href=http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e8e1ca2b036c6bcbd582af4b216275873849c35585cc3b2d6e825eca803671c6.css integrity="sha256-6OHKKwNsa8vVgq9LIWJ1hzhJw1WFzDstboJeyoA2ccY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><meta property="og:title" content="Merkle Trees for Whitelists in JS"><meta property="og:description" content="In this article, we&rsquo;ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-24T15:04:11+02:00"><meta property="article:modified_time" content="2024-05-24T15:04:11+02:00"><meta property="og:site_name" content="wentel drop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Merkle Trees for Whitelists in JS"><meta name=twitter:description content="In this article, we&rsquo;ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Merkle Trees for Whitelists in JS","item":"http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Merkle Trees for Whitelists in JS","name":"Merkle Trees for Whitelists in JS","description":"In this article, we\u0026rsquo;ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples.","keywords":["JS","merkle tree","merkle proof"],"articleBody":"In this article, we’ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples.\n1. Introduction to Merkle Trees A Merkle tree is a hash-based data structure constructed from arbitrary data using a fixed hash function $H$. The primary advantage of this data structure is that it enables us to prove the inclusion of a certain piece of data in the tree without needing to store the data itself. This is possible through the clever use of a hash function combined with a tree structure. A hash function accepts input of arbitrary length and consistently produces a unique fixed-length string, meaning that two different pieces of data will always yield two distinct hashes. In what follows, we will focus on binary Merkle trees, where each node can have at most two children.\nBefore delving into the general construction process of Merkle trees, let’s examine a minimal example. The diagram below illustrates a Merkle tree created using the strings satoshi@nakamoto.com and vitalik@buterin.ca with the SHA-256 hash function. This specific Merkle tree contains only three nodes: two leaves and one root node.\ngraph TB; subgraph ED[ ] A[\"H12 = SHA256(H1 + H2)\"]:::safeStyle--\u003e B[\"H1 = SHA256(D1)\"]:::safeStyle; A--\u003eC[\"H2 = SHA256(D2)\"]:::safeStyle; end B---D[\"D1 = 'satoshi@nakamoto.com'\"] C---E[\"D2 = 'vitalik@buterin.ca'\"] style ED color:#12FF80, fill:none classDef safeStyle stroke:#12FF80 The leaf nodes of this Merkle tree are formed by hashing the strings $D_1$ and $D_2$ using the SHA-256 hash function. The root node $H_{12}$ is derived by concatenating these two hashes and hashing the result again. It’s important to note that the actual data, specifically the strings $D_1$ and $D_2$, are not included in the tree; only their hashes are.\nThe root hash represents the entire set of leaf nodes and is a cryptographic commitment to the initial data set. If we would change just a single symbol of one of the input strings this would result in different leaf hashes and thus in a different root hash. This simple example already encapsulates the general construction procedure of a Merkle tree:\nStart with Leaf Nodes: We begin by hashing the data to obtain a list of hash values. These hashes serve as the leaf nodes of the Merkle tree. Pair and Hash: We pair each leaf node with its sibling. For every such pair, we concatenate their hash values and hash the resulting value. This process yields the parent nodes at the next level of the tree. If a leaf node does not have a sibling, which happens when the number of leaf nodes is odd, we either duplicate that lone leaf or insert a leaf with a default value. This adjustment ensures an even number of nodes for pairing. Although not essential for Merkle proofs, this method is typically employed to enhance the efficiency of the data structure. This pairing and hashing process is repeated for each level of the tree until we reach the top of the tree. This single hash is the root of the Merkle tree.\n2. Merkle Proofs for Whitelists A Merkle proof is a set of hashes that can be used to verify that a specific leaf is part of a Merkle tree. By utilizing the leaf hash and the hashes from the Merkle proof, we can recompute the Merkle root. This recomputed root is then compared to the publicly available Merkle root of the tree, confirming the inclusion of the leaf in the tree.\nA common use of Merkle trees in Web3 is maintaining whitelists, where users may be granted privileges, such as NFT minting, based on prior selection. In this scenario, unique user data must be stored in the whitelist. While real-world applications often use account addresses for this purpose, we’ll simplify by extending our introduction example using email addresses. Let’s assume that our whitelist consists of the following three email addresses: satoshi@nakamoto.com, vitalik@buterin.ca and gavin@wood.de.\ngraph TB; subgraph ED[ ] A[\"H1234 = H(H12 + H34)\"] --\u003e B[\"H12 = H(H1+H2)\"]; A--\u003eC[\"H34 = H(H3+H4)\"]; B--\u003eD[\"H1\"]; B--\u003eE[\"H2\"]; C--\u003eF[\"H3\"]; C--\u003eG[\"H4\"]; end D---H[\"D1 = 'satoshi@nakamoto.com'\"] E---I[\"D2 = 'vitalik@buterin.ca'\"] F---J[\"D3 = 'gavin@wood.de'\"] G---K[\"D4 = ' '\"] style ED color:#12FF80, fill:none style E stroke:#12FF80,stroke-width:4px style I stroke:#12FF80,stroke-width:4px style D stroke:#12FF80,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style C stroke:#12FF80,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 Example: The leaves $H_1$ through $H_3$ of this Merkle tree are obtained by hashing the email addresses of our whitelist. Additionally, we included $D_4$ as an empty string to keep the tree balanced. The Merkle proof for $H_2$ is given by the array of hashes $[H_{1}, H_{34}]$. Given the root $H_{1234}$ of the tree we can verify the proof as follows:\nCompute $H’_{12}$ by concatenating and then hashing $H_1$ and $H_2$. Compute $H’_{1234}$ by concatenating and then hashing the previously computed $H’_{12}$ with $H_{34}$. Compare $H_{1234}$ with the computed $H’_{1234}$. If the hashes are equal, the proof is valid; otherwise, it is invalid. If we want to obtain a Merkle proof for $H_3$ instead, then the necessary hashes are $H_4$ and $H_{12}$.\nRecalling our introductory example from the previous section, where we created a Merkle tree using only two email addresses, we can now see how a Merkle proof is formed for the inclusion of one of these addresses in the tree. A Merkle proof for the inclusion of $D_1$ requires only the hash $H_2$, analogously the proof for $D_2$ requires knowledge of $H_1$.\nIn general, we can obtain a Merkle proof by starting from the selected leaf and moving up the tree. At each level, we select the sibling node and add it to the proof list. The sibling node is necessary because it provides the information needed to reconstruct the parent node at each step. We continue this process of moving up the tree, selecting sibling nodes at each level, until we reach the root of the Merkle tree. The collection of these sibling nodes forms the Merkle proof.\nThe significant advantage of this approach in Web3 applications is that only the Merkle root needs to be stored on-chain, whereas the actual tree can be stored off-chain in a backend. A smart contract can then be used to verify a proof for a specific leaf. This is crucial, as block space is typically a costly resource.\n3. JS Implementation using merkletreejs Prerequisites: Node.js, npm\nIn this section, we will use the JavaScript library merkletreejs to implement a Merkle tree for email whitelisting. Specifically, we will demonstrate how to construct a Merkle tree using three email addresses and how to obtain and verify the corresponding Merkle proofs.\nFirst, create a new folder, initialize a new Node.js project using npm, and install merkletreejs along with crypto-js:\nnpm init -y npm install merkletreejs crypto-js Next, create an empty file named merkle.js and paste the following JavaScript code:\nconst { MerkleTree } = require('merkletreejs') const SHA256 = require('crypto-js/sha256') // Sample data const leaves = ['satoshi@nakamoto.com', 'vitalik@buterin.ca', 'gavin@wood.de', ''].map(x =\u003e SHA256(x)) // Initialize the Merkle Tree const tree = new MerkleTree(leaves, SHA256, { sortPairs: true }) // Log the tree console.log('Merkle tree:\\n', tree.toString()); This code snippet implements the scenario described earlier, where we construct a Merkle tree using email addresses as input data. Notice that we have also included an empty string in the leaves array to balance the tree. We use the SHA256 function from crypto-js to generate the leaves from our data, which forms the foundation of the Merkle tree. Then, we initialize a new Merkle tree by invoking the MerkleTree constructor from merkletreejs, passing in our leaves array and the SHA256 hash function. Additionally, we need to set the sortPairs flag to true to enable hexadecimal proof verification.\nRunning node merkle.js will log the newly created Merkle tree to the console:\nMerkle tree: └─ 3091e77ff091717dbc4c42aaa48ed37c3da445916e86a19466a38eee2f74cb28 ├─ 639983b835d9c5320b34589e9523d2859bb99f91a2f81caea526a6ed03567150 │ ├─ 038a33cbcf36f6fe7f270188fc4cd48087cd6dddc2120d39d5e225191676183e │ └─ 67e7a3cbbe8c4dd8bd640170dcf45b7181aa7b73c03a3449df2fbe392e494501 └─ fb228476e81f4e4edd4b9d5ed03ed5b54cf37e9098e3835ae6df6b92410a78f3 ├─ c89a41f732b7981100fcc6bec235c83aec0e1674c692dc475b226ee56a4aea76 └─ e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 This output corresponds to the following tree diagram:\ngraph TB; subgraph ED[ ] A[\"0x309...\"]:::safeStyle--\u003eB[\"0x639...\"]:::safeStyle; A--\u003eC[\"0xfb2...\"]:::safeStyle; B--\u003eD[\"0x038...\"]:::safeStyle; B--\u003eE[\"0x67e...\"]:::safeStyle; C--\u003eF[\"0xc89...\"]:::safeStyle; C--\u003eG[\"0xe3b...\"]:::safeStyle; end D---H[\"D1 = 'satoshi@nakamoto.com'\"] E---I[\"D2 = 'vitalik@buterin.ca'\"] F---J[\"D3 = 'gavin@wood.de'\"] G---K[\"D4 = ' '\"] classDef safeStyle stroke:#12FF80 style ED color:#12FF80, fill:none To verify if the email address vitalik@buterin.ca is included in the Merkle tree, we can use the getHexProof method from the tree object to obtain a Merkle proof in hexadecimal format. For this, we only require the hash of the address. Append the following lines to your existing code:\n// Get the Merkle proof for 'vitalik@buterin.ca' const leaf = SHA256('vitalik@buterin.ca'); const proof = tree.getHexProof(leaf); // Output the proof console.log('Merkle Proof for \"vitalik@buterin.ca\":', proof); Executing node merkle.js again will print the Merkle proof for vitalik@buterin.ca to the console:\nMerkle Proof for \"vitalik@buterin.ca\": [ '0x038a33cbcf36f6fe7f270188fc4cd48087cd6dddc2120d39d5e225191676183e', '0xfb228476e81f4e4edd4b9d5ed03ed5b54cf37e9098e3835ae6df6b92410a78f3' ] Since the address vitalik@buterin.ca is represented by the second leaf node from the left, we can visually verify, using the previous diagram, that these hashes are precisely what’s needed for a valid Merkle proof. To confirm the proof’s validity, we use the verify method of the tree object. Add the following lines to your code and execute node merkle.js once more:\n// Get the root of the tree const root = tree.getRoot().toString('hex'); // Verify the proof for 'vitalik@buterin.ca' console.log(tree.verify(proof, leaf, root)) // true As expected, the proof verification is successful. To understand what happens when we try to obtain and verify a proof for an email not included in the Merkle tree, let’s add the following lines:\n// Get the Merkle proof for non-existing 'bitalik@buterin.ca' const badleaf = SHA256('bitalik@buterin.ca'); const badproof = tree.getHexProof(badleaf); // Output the proof console.log('Merkle Proof for \"bitalik@buterin.ca\":', badproof); // Verify the proof for 'bitalik@buterin.ca' console.log(tree.verify(badproof, badleaf, root)) // false This results in an empty proof and, consequently, verification fails:\nMerkle Proof for \"bitalik@buterin.ca\": [] false ","wordCount":"1602","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-05-24T15:04:11+02:00","dateModified":"2024-05-24T15:04:11+02:00","author":{"@type":"Person","name":"wentelteefje"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/merkle-trees-and-merkle-proofs-in-js/"},"publisher":{"@type":"Organization","name":"a5xz2","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="wentel drop (Alt + H)"><img src=http://localhost:1313/logo-wentelw.png alt aria-label=logo height=75>wentel drop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/posts/ title=writings><span>writings</span></a></li><li><a href=http://localhost:1313/publications/ title=publications><span>publications</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Merkle Trees for Whitelists in JS
<span class=entry-hint title=Draft><svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2024-05-24 15:04:11 +0200 CEST'>May 24, 2024</span>&nbsp;·&nbsp;wentelteefje&nbsp;|&nbsp;<a href=https://github.com/wentelteefje/wentelteefje.github.io/content/posts/merkle-trees-and-merkle-proofs-in-js.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-introduction-to-merkle-trees>1. Introduction to Merkle Trees</a></li><li><a href=#2-merkle-proofs-for-whitelists>2. Merkle Proofs for Whitelists</a></li><li><a href=#3-js-implementation-using-merkletreejs>3. JS Implementation using <code>merkletreejs</code></a></li></ul></nav></div></details></div><div class=post-content><p>In this article, we&rsquo;ll explore Merkle trees and Merkle proofs, covering how they work, their role in blockchain systems, and how to build them with a focus on both theory and practical examples.</p><h2 id=1-introduction-to-merkle-trees>1. Introduction to Merkle Trees<a hidden class=anchor aria-hidden=true href=#1-introduction-to-merkle-trees>#</a></h2><p>A Merkle tree is a hash-based data structure constructed from arbitrary data using a fixed hash function $H$. The primary advantage of this data structure is that it enables us to prove the inclusion of a certain piece of data in the tree without needing to store the data itself. This is possible through the clever use of a hash function combined with a tree structure. A hash function accepts input of arbitrary length and consistently produces a unique fixed-length string, meaning that two different pieces of data will always yield two distinct hashes. In what follows, we will focus on binary Merkle trees, where each node can have at most two children.</p><p>Before delving into the general construction process of Merkle trees, let&rsquo;s examine a minimal example. The diagram below illustrates a Merkle tree created using the strings <code>satoshi@nakamoto.com</code> and <code>vitalik@buterin.ca</code> with the <code>SHA-256</code> hash function. This specific Merkle tree contains only three nodes: two leaves and one root node.</p><pre class=mermaid>graph TB;
    subgraph ED[ ]
    A["H12 = SHA256(H1 + H2)"]:::safeStyle-->
    B["H1 = SHA256(D1)"]:::safeStyle;
    A-->C["H2 = SHA256(D2)"]:::safeStyle;
    end
    B---D["D1 = 'satoshi@nakamoto.com'"]
    C---E["D2 = 'vitalik@buterin.ca'"]
    style ED color:#12FF80, fill:none
    classDef safeStyle stroke:#12FF80
</pre><p>The leaf nodes of this Merkle tree are formed by hashing the strings $D_1$ and $D_2$ using the <code>SHA-256</code> hash function. The root node $H_{12}$ is derived by concatenating these two hashes and hashing the result again. It&rsquo;s important to note that the actual data, specifically the strings $D_1$ and $D_2$, are not included in the tree; only their hashes are.</p><p>The root hash represents the entire set of leaf nodes and is a cryptographic commitment to the initial data set. If we would change just a single symbol of one of the input strings this would result in different leaf hashes and thus in a different root hash. This simple example already encapsulates the general construction procedure of a Merkle tree:</p><ol><li><strong>Start with Leaf Nodes</strong>: We begin by hashing the data to obtain a list of hash values. These hashes serve as the leaf nodes of the Merkle tree.</li><li><strong>Pair and Hash</strong>: We pair each leaf node with its sibling. For every such pair, we concatenate their hash values and hash the resulting value. This process yields the parent nodes at the next level of the tree. If a leaf node does not have a sibling, which happens when the number of leaf nodes is odd, we either duplicate that lone leaf or insert a leaf with a default value. This adjustment ensures an even number of nodes for pairing. Although not essential for Merkle proofs, this method is typically employed to enhance the efficiency of the data structure.</li></ol><p>This pairing and hashing process is repeated for each level of the tree until we reach the top of the tree. This single hash is the root of the Merkle tree.</p><h2 id=2-merkle-proofs-for-whitelists>2. Merkle Proofs for Whitelists<a hidden class=anchor aria-hidden=true href=#2-merkle-proofs-for-whitelists>#</a></h2><p>A Merkle proof is a set of hashes that can be used to verify that a specific leaf is part of a Merkle tree. By utilizing the leaf hash and the hashes from the Merkle proof, we can recompute the Merkle root. This recomputed root is then compared to the publicly available Merkle root of the tree, confirming the inclusion of the leaf in the tree.</p><p>A common use of Merkle trees in Web3 is maintaining whitelists, where users may be granted privileges, such as NFT minting, based on prior selection. In this scenario, unique user data must be stored in the whitelist. While real-world applications often use account addresses for this purpose, we&rsquo;ll simplify by extending our introduction example using email addresses. Let&rsquo;s assume that our whitelist consists of the following three email addresses: <code>satoshi@nakamoto.com</code>, <code>vitalik@buterin.ca</code> and <code>gavin@wood.de</code>.</p><pre class=mermaid>graph TB;
    subgraph ED[ ]
    A["H1234 = H(H12 + H34)"]
    --> B["H12 = H(H1+H2)"];
    A-->C["H34 = H(H3+H4)"];
    B-->D["H1"];
    B-->E["H2"];
    C-->F["H3"];
    C-->G["H4"];
    end
    D---H["D1 = 'satoshi@nakamoto.com'"]
    E---I["D2 = 'vitalik@buterin.ca'"]
    F---J["D3 = 'gavin@wood.de'"]
    G---K["D4 = ' '"]
    style ED color:#12FF80, fill:none
    style E stroke:#12FF80,stroke-width:4px
    style I stroke:#12FF80,stroke-width:4px
    style D stroke:#12FF80,stroke-width:2px,color:#fff,stroke-dasharray: 5 5
    style C stroke:#12FF80,stroke-width:2px,color:#fff,stroke-dasharray: 5 5
</pre><p><strong>Example</strong>: The leaves $H_1$ through $H_3$ of this Merkle tree are obtained by hashing the email addresses of our whitelist. Additionally, we included $D_4$ as an empty string to keep the tree balanced. The Merkle proof for $H_2$ is given by the array of hashes $[H_{1}, H_{34}]$. Given the root $H_{1234}$ of the tree we can verify the proof as follows:</p><ol><li>Compute $H&rsquo;_{12}$ by concatenating and then hashing $H_1$ and $H_2$.</li><li>Compute $H&rsquo;_{1234}$ by concatenating and then hashing the previously computed $H&rsquo;_{12}$ with $H_{34}$.</li><li>Compare $H_{1234}$ with the computed $H&rsquo;_{1234}$. If the hashes are equal, the proof is valid; otherwise, it is invalid.</li></ol><p>If we want to obtain a Merkle proof for $H_3$ instead, then the necessary hashes are $H_4$ and $H_{12}$.</p><p>Recalling our introductory example from the previous section, where we created a Merkle tree using only two email addresses, we can now see how a Merkle proof is formed for the inclusion of one of these addresses in the tree. A Merkle proof for the inclusion of $D_1$ requires only the hash $H_2$, analogously the proof for $D_2$ requires knowledge of $H_1$.</p><p>In general, we can obtain a Merkle proof by starting from the selected leaf and moving up the tree. At each level, we select the sibling node and add it to the proof list. The sibling node is necessary because it provides the information needed to reconstruct the parent node at each step. We continue this process of moving up the tree, selecting sibling nodes at each level, until we reach the root of the Merkle tree. The collection of these sibling nodes forms the Merkle proof.</p><p>The significant advantage of this approach in Web3 applications is that only the Merkle root needs to be stored on-chain, whereas the actual tree can be stored off-chain in a backend. A smart contract can then be used to verify a proof for a specific leaf. This is crucial, as block space is typically a costly resource.</p><h2 id=3-js-implementation-using-merkletreejs>3. JS Implementation using <code>merkletreejs</code><a hidden class=anchor aria-hidden=true href=#3-js-implementation-using-merkletreejs>#</a></h2><p><strong>Prerequisites</strong>: Node.js, npm</p><p>In this section, we will use the JavaScript library <code>merkletreejs</code> to implement a Merkle tree for email whitelisting. Specifically, we will demonstrate how to construct a Merkle tree using three email addresses and how to obtain and verify the corresponding Merkle proofs.</p><p>First, create a new folder, initialize a new Node.js project using npm, and install <code>merkletreejs</code> along with <code>crypto-js</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>npm init -y
</span></span><span class=line><span class=cl>npm install merkletreejs crypto-js 
</span></span></code></pre></div><p>Next, create an empty file named <code>merkle.js</code> and paste the following JavaScript code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>MerkleTree</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;merkletreejs&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SHA256</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;crypto-js/sha256&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Sample data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>leaves</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;satoshi@nakamoto.com&#39;</span><span class=p>,</span> <span class=s1>&#39;vitalik@buterin.ca&#39;</span><span class=p>,</span> <span class=s1>&#39;gavin@wood.de&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>].</span><span class=nx>map</span><span class=p>(</span><span class=nx>x</span> <span class=p>=&gt;</span> <span class=nx>SHA256</span><span class=p>(</span><span class=nx>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Initialize the Merkle Tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>tree</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>MerkleTree</span><span class=p>(</span><span class=nx>leaves</span><span class=p>,</span> <span class=nx>SHA256</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sortPairs</span><span class=o>:</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Log the tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Merkle tree:\n&#39;</span><span class=p>,</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>toString</span><span class=p>());</span>
</span></span></code></pre></div><p>This code snippet implements the scenario described earlier, where we construct a Merkle tree using email addresses as input data. Notice that we have also included an empty string in the <code>leaves</code> array to balance the tree. We use the <code>SHA256</code> function from <code>crypto-js</code> to generate the leaves from our data, which forms the foundation of the Merkle tree. Then, we initialize a new Merkle tree by invoking the <code>MerkleTree</code> constructor from <code>merkletreejs</code>, passing in our <code>leaves</code> array and the <code>SHA256</code> hash function. Additionally, we need to set the <code>sortPairs</code> flag to <code>true</code> to enable hexadecimal proof verification.</p><p>Running <code>node merkle.js</code> will log the newly created Merkle tree to the console:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Merkle tree:
</span></span><span class=line><span class=cl> └─ 3091e77ff091717dbc4c42aaa48ed37c3da445916e86a19466a38eee2f74cb28
</span></span><span class=line><span class=cl>   ├─ 639983b835d9c5320b34589e9523d2859bb99f91a2f81caea526a6ed03567150
</span></span><span class=line><span class=cl>   │  ├─ 038a33cbcf36f6fe7f270188fc4cd48087cd6dddc2120d39d5e225191676183e
</span></span><span class=line><span class=cl>   │  └─ 67e7a3cbbe8c4dd8bd640170dcf45b7181aa7b73c03a3449df2fbe392e494501
</span></span><span class=line><span class=cl>   └─ fb228476e81f4e4edd4b9d5ed03ed5b54cf37e9098e3835ae6df6b92410a78f3
</span></span><span class=line><span class=cl>      ├─ c89a41f732b7981100fcc6bec235c83aec0e1674c692dc475b226ee56a4aea76
</span></span><span class=line><span class=cl>      └─ e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</span></span></code></pre></div><p>This output corresponds to the following tree diagram:</p><pre class=mermaid>graph TB;
    subgraph ED[ ]
    A["0x309..."]:::safeStyle-->B["0x639..."]:::safeStyle;
    A-->C["0xfb2..."]:::safeStyle;
    B-->D["0x038..."]:::safeStyle;
    B-->E["0x67e..."]:::safeStyle;
    C-->F["0xc89..."]:::safeStyle;
    C-->G["0xe3b..."]:::safeStyle;
    end
    D---H["D1 = 'satoshi@nakamoto.com'"]
    E---I["D2 = 'vitalik@buterin.ca'"]
    F---J["D3 = 'gavin@wood.de'"]
    G---K["D4 = ' '"]
    classDef safeStyle stroke:#12FF80
    style ED color:#12FF80, fill:none
</pre><p>To verify if the email address <code>vitalik@buterin.ca</code> is included in the Merkle tree, we can use the <code>getHexProof</code> method from the <code>tree</code> object to obtain a Merkle proof in hexadecimal format. For this, we only require the hash of the address. Append the following lines to your existing code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=cl><span class=c1>// Get the Merkle proof for &#39;vitalik@buterin.ca&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>leaf</span> <span class=o>=</span> <span class=nx>SHA256</span><span class=p>(</span><span class=s1>&#39;vitalik@buterin.ca&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>proof</span> <span class=o>=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>getHexProof</span><span class=p>(</span><span class=nx>leaf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output the proof
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Merkle Proof for &#34;vitalik@buterin.ca&#34;:&#39;</span><span class=p>,</span> <span class=nx>proof</span><span class=p>);</span>
</span></span></code></pre></div><p>Executing <code>node merkle.js</code> again will print the Merkle proof for <code>vitalik@buterin.ca</code> to the console:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Merkle Proof <span class=k>for</span> <span class=s2>&#34;vitalik@buterin.ca&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;0x038a33cbcf36f6fe7f270188fc4cd48087cd6dddc2120d39d5e225191676183e&#39;</span>,
</span></span><span class=line><span class=cl>  <span class=s1>&#39;0xfb228476e81f4e4edd4b9d5ed03ed5b54cf37e9098e3835ae6df6b92410a78f3&#39;</span>
</span></span><span class=line><span class=cl><span class=o>]</span>
</span></span></code></pre></div><p>Since the address <code>vitalik@buterin.ca</code> is represented by the second leaf node from the left, we can visually verify, using the previous diagram, that these hashes are precisely what&rsquo;s needed for a valid Merkle proof. To confirm the proof&rsquo;s validity, we use the <code>verify</code> method of the <code>tree</code> object. Add the following lines to your code and execute <code>node merkle.js</code> once more:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=cl><span class=c1>// Get the root of the tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>root</span> <span class=o>=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>getRoot</span><span class=p>().</span><span class=nx>toString</span><span class=p>(</span><span class=s1>&#39;hex&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Verify the proof for &#39;vitalik@buterin.ca&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nx>verify</span><span class=p>(</span><span class=nx>proof</span><span class=p>,</span> <span class=nx>leaf</span><span class=p>,</span> <span class=nx>root</span><span class=p>))</span> <span class=c1>// true
</span></span></span></code></pre></div><p>As expected, the proof verification is successful. To understand what happens when we try to obtain and verify a proof for an email not included in the Merkle tree, let&rsquo;s add the following lines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Javascript data-lang=Javascript><span class=line><span class=cl><span class=c1>// Get the Merkle proof for non-existing &#39;bitalik@buterin.ca&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>badleaf</span> <span class=o>=</span> <span class=nx>SHA256</span><span class=p>(</span><span class=s1>&#39;bitalik@buterin.ca&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>badproof</span> <span class=o>=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>getHexProof</span><span class=p>(</span><span class=nx>badleaf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output the proof
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Merkle Proof for &#34;bitalik@buterin.ca&#34;:&#39;</span><span class=p>,</span> <span class=nx>badproof</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Verify the proof for &#39;bitalik@buterin.ca&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nx>verify</span><span class=p>(</span><span class=nx>badproof</span><span class=p>,</span> <span class=nx>badleaf</span><span class=p>,</span> <span class=nx>root</span><span class=p>))</span> <span class=c1>// false
</span></span></span></code></pre></div><p>This results in an empty proof and, consequently, verification fails:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Merkle Proof <span class=k>for</span> <span class=s2>&#34;bitalik@buterin.ca&#34;</span>: <span class=o>[]</span>
</span></span><span class=line><span class=cl><span class=nb>false</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/js/>JS</a></li><li><a href=http://localhost:1313/tags/merkle-tree/>Merkle Tree</a></li><li><a href=http://localhost:1313/tags/merkle-proof/>Merkle Proof</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/zkhack-power-corrupts-puzzle/><span class=title>« Prev</span><br><span>ZK Hack Power Corrupts Puzzle</span>
</a><a class=next href=http://localhost:1313/posts/post-005/><span class=title>Next »</span><br><span>ZK004: Optimal Ate Pairing in Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>a5xz2</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>